<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mood的个人博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-17T02:37:51.376Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Mood</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springcloud整合minio时出现的错误</title>
    <link href="http://example.com/2023/09/17/springcloud%E6%95%B4%E5%90%88minio%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <id>http://example.com/2023/09/17/springcloud%E6%95%B4%E5%90%88minio%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/</id>
    <published>2023-09-17T03:24:56.000Z</published>
    <updated>2023-09-17T02:37:51.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Action-Correct-the-classpath-of-your-application-so-that-it-contains-compatible-versions-of-the-classes-io-minio-S3Base-and-okhttp3-RequestBody"><a href="#Action-Correct-the-classpath-of-your-application-so-that-it-contains-compatible-versions-of-the-classes-io-minio-S3Base-and-okhttp3-RequestBody" class="headerlink" title="Action:Correct the classpath of your application so that it contains compatible versions of the classes io.minio.S3Base and okhttp3.RequestBody"></a>Action:Correct the classpath of your application so that it contains compatible versions of the classes io.minio.S3Base and okhttp3.RequestBody</h3><p>这个错误是我在整合minio时报的错，说实话遇到这个错误我还是很头大的，因为之前在springboot项目中整合过一次minio，当时报的错误跟这个差不多，都是okhttp版本依赖问题，之前是因为，我的minio依赖里面自带的okhttp包的版本过低，需要将minio包中的okhttp包剔除，自己手动引进一个更高版本的okhttp包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--maven引入minio排除okhttp依赖并添加高版本的okhttp依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.minio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>minio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就像上述代码一样，这样就可以解决okhttp版本的问题。但是这次报的错误跟上次几乎一样，追根揭底也是okhttp包版本问题，这次是版本冲突问题。</p><p>这就是这个错误奇怪的地方，发现是版本冲突后，我查看了这个项目的版本依赖，但是没有发现有关okhttp的版本冲突存在。</p><p>又从头看了一下报错信息，发现了一个奇怪的地方。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The called method&#x27;s class, okhttp3.RequestBody, is available from the following locations:</span><br><span class="line"></span><br><span class="line">    jar:file:/D:/repository/com/squareup/okhttp3/okhttp/3.14.9/okhttp-3.14.9.jar!/okhttp3/RequestBody.class</span><br><span class="line"></span><br><span class="line">The called method&#x27;s class hierarchy was loaded from the following locations:</span><br><span class="line"></span><br><span class="line">    okhttp3.RequestBody: file:/D:/repository/com/squareup/okhttp3/okhttp/3.14.9/okhttp-3.14.9.jar</span><br></pre></td></tr></table></figure><p>它不知道从哪给我加载了一个3.14.9版本的okhttp，而我引入的依赖是4.9.0的版本，然后我又看了一下我项目引入的依赖库，确实找到了两个版本的okhttp。</p><p><img src="https://tt.xtt.ovh/imgs/2023/09/17/29d5e48c5fcd2cac.png" alt="okhttp版本冲突"></p><p>然后我就开始找这个3.14.9版本的okhttp是从哪里引进来的，自己折腾了一大晌还是没有找到，后来就放弃了，等到第二天再来看这个错误的时候，在这个okhttp依赖旁边发现了这个</p><p><img src="https://tt.xtt.ovh/imgs/2023/09/17/20aac83bc9df3c5b.png" alt="okhttpmaven依赖"></p><p>本来也是没发现什么异常，就是实在没法了点了一下，就进到了这里</p><p><img src="https://tt.xtt.ovh/imgs/2023/09/17/171cc12cd1368c65.png" alt="okhttp依赖版本控制"></p><p>嘿，搁这找到了，往上翻，找到他的版本号</p><p><img src="https://tt.xtt.ovh/imgs/2023/09/17/37239131e740b369.png" alt="okhttp版本号"></p><p>好家伙，原来搁这了，那现在就是想办法把这个版本号给覆盖掉就行了，在我的这个项目的父工程里加入这个okhttp的版本号，在这个项目里引用这个版本号，重新启动，问题解决。</p><p><img src="https://tt.xtt.ovh/imgs/2023/09/17/f5d5fd4152991e2e.png" alt="版本号指定"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--maven引入minio排除okhttp依赖并添加高版本的okhttp依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.minio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>minio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;okhttp3.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Action-Correct-the-classpath-of-your-application-so-that-it-contains-compatible-versions-of-the-classes-io-minio-S3Base-and-okhttp3-</summary>
      
    
    
    
    <category term="minio" scheme="http://example.com/categories/minio/"/>
    
    
    <category term="minio" scheme="http://example.com/tags/minio/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList的扩容机制</title>
    <link href="http://example.com/2023/07/21/ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2023/07/21/ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</id>
    <published>2023-07-21T03:24:56.000Z</published>
    <updated>2023-07-23T08:23:19.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h2><p>​        ArrayList是基于数组实现的集合，虽然是基于数组实现，却比数组要方便许多，比如初始化时可以不指定其长度；指定长度后，其大小也不是固定不变，会跟据你存储的元素的逐渐增多而增加；等等。今天说一下ArrayList的扩容机制是如何实现的。</p><p>​首先我们看一下ArrayList的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;<span class="comment">//可以指定集合的长度</span></span><br><span class="line">    <span class="comment">//其中的elementData是ArrayList中用来存储元素的数组</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//大于零则对elementData数组进行初始化</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//等于0则采用自带的空数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//小于0则抛异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这是无参构造，给elementData赋值自带的空数组</span></span><br><span class="line">    <span class="comment">//这个数组跟上面的空数组不一样，虽然都是空数组，但一个是调用无参构造是赋值的，一个是调用有参构造，但是传值为0是赋值的数组</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;<span class="comment">//将一个集合转为ArrayList</span></span><br><span class="line">        Object[] a = c.toArray();<span class="comment">//先将其转为Object类型的数组</span></span><br><span class="line">        <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;<span class="comment">//如果这个数组不为空，进行copy</span></span><br><span class="line">            <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;<span class="comment">//如果这个集合就是ArrayList类型，则直接进行elementData数组的赋值</span></span><br><span class="line">                elementData = a;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//进行elementData数组的copy</span></span><br><span class="line">                elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 替换为空数组</span></span><br><span class="line">            elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后就是ArrayList的扩容机制，这个在向ArrayList中添加元素时触发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//size + 1 是添加元素之后的元素个数，此时需要判断是否超过数组大小</span></span><br><span class="line">        elementData[size++] = e;<span class="comment">//确认不会越界之后或着扩容之后，在进行添加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//此方法是先确认elementData需要的长度，之后再判断是否需要扩容，此方法只是起到一个方法调用的作用，扩容得核心不在这里</span></span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//此方法是确认elementData需要的长度</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<span class="comment">//若elementData数组是默认空数组，说明初始化时没有指定长度</span></span><br><span class="line">            <span class="comment">//DEFAULT_CAPACITY是ArrayList的默认长度  为10</span></span><br><span class="line">            <span class="comment">//minCapacity是elementData数组添加元素后的元素个数</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">            <span class="comment">//若添加元素后的元素个数还比默认长度小，则仍采用默认长度，否则采用minCapacity（添加元素后的元素个数，数组需要的最小长度）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;<span class="comment">//minCapacity为数组现在需要的长度</span></span><br><span class="line">        modCount++;<span class="comment">//操作数加1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要扩容的方法</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);<span class="comment">//现在需要的长度 &lt; 现有的长度  -》需要扩容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;<span class="comment">//扩容机制的核心</span></span><br><span class="line">        <span class="comment">//数组原来的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">//数组的新长度，为原来的长度的1.5倍</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//若新长度仍小于数组现需要的大小，则将新长度设为现在需要的长度</span></span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//若新长度大于ArrayList设置的最大长度，则将新长度设置为ArrayList指定的最大长度MAX_ARRAY_SIZE</span></span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// 进行数组的copy</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;<span class="comment">//保证数组最大为MAX_ARRAY_SIZE</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>这就是ArrayList的扩容机制，这纯属个人理解，如有错误，欢迎指正。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ArrayList的扩容机制&quot;&gt;&lt;a href=&quot;#ArrayList的扩容机制&quot; class=&quot;headerlink&quot; title=&quot;ArrayList的扩容机制&quot;&gt;&lt;/a&gt;ArrayList的扩容机制&lt;/h2&gt;&lt;p&gt;​        ArrayList是基于数</summary>
      
    
    
    
    <category term="源码" scheme="http://example.com/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="ArrayList" scheme="http://example.com/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/07/19/hello-world/"/>
    <id>http://example.com/2023/07/19/hello-world/</id>
    <published>2023-07-19T07:56:16.000Z</published>
    <updated>2023-07-21T01:31:53.949Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
    <category term="1" scheme="http://example.com/tags/1/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="http://example.com/2023/07/17/RabbitMQ/"/>
    <id>http://example.com/2023/07/17/RabbitMQ/</id>
    <published>2023-07-17T03:24:56.000Z</published>
    <updated>2023-07-23T08:36:05.629Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="RabbitMQ概念"><a href="#RabbitMQ概念" class="headerlink" title="RabbitMQ概念"></a>RabbitMQ概念</h4><p>​RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p><h4 id="使用Docker安装RabbitMQ"><a href="#使用Docker安装RabbitMQ" class="headerlink" title="使用Docker安装RabbitMQ"></a>使用Docker安装RabbitMQ</h4><ol><li>拉取镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:management   #带management是有管理页面的镜像</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个数据卷，用于持久化RabbitMQ的所有数据，方便管理</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create rabbitmq-home</span><br></pre></td></tr></table></figure><ol start="3"><li>创建并运行容器</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name=rabbitmq \</span><br><span class="line">-v rabbitmq-home:/var/lib/rabbitmq \</span><br><span class="line">-p 15672:15672 -p 5672:5672 \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=rabbitmq \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=123456mq \</span><br><span class="line">rabbitmq:management</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">15672端口：RabbitMQ的管理页面端口</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5672端口：RabbitMQ的消息接收端口</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">RABBITMQ_DEFAULT_USER环境变量：指定RabbitMQ的用户名</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">RABBITMQ_DEFAULT_PASS环境变量：指定RabbitMQ的密码</span></span><br></pre></td></tr></table></figure><h4 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h4><p><strong>生产者</strong>：产生数据发送消息的程序</p><p><strong>交换机</strong>：是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p><p><strong>队列</strong>：是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p><p><strong>消费者</strong>：消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p><h4 id="各个名词介绍"><a href="#各个名词介绍" class="headerlink" title="各个名词介绍"></a>各个名词介绍</h4><p><img src="https://tt.xtt.ovh/imgs/2023/07/21/11f46110bd4fadcb.png"></p><p><strong><code>Broker</code>：</strong>接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p><p><strong><code>Virtual host</code>：</strong>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p><p><strong><code>Connection</code>：</strong>publisher／consumer 和 broker 之间的 TCP 连接</p><p><strong><code>Channel</code>：</strong>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</p><p><strong><code>Exchange</code>：</strong>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point)，topic (publish-subscribe) and fanout (multicast)</p><p><strong><code>Queue</code>：</strong>消息最终被送到这里等待 consumer 取走</p><p><strong><code>Binding</code>：</strong>exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据</p><h4 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h4><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费者的消息，因为它无法接收到。</p><p>为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</p><h5 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h5><p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，<strong>所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。</strong></p><h5 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h5><p>由用户自己设定应答方式，可根据需要调整。</p><p>手动应答方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel.basicAck(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple);<span class="comment">//肯定确认应答</span></span><br></pre></td></tr></table></figure><p>第一个参数是消息的标记，第二个参数表示是否应用于多消息，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel.basicReject(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> requeue);<span class="comment">//否定确认应答</span></span><br></pre></td></tr></table></figure><p>第一个参数表示拒绝 <code>deliveryTag</code> 对应的消息，第二个参数表示是否 <code>requeue</code>：true 则重新入队列，false 则丢弃或者进入死信队列。</p><p>该方法 reject 后，该消费者还是会消费到该条被 reject 的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel.basicNack(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple, <span class="type">boolean</span> requeue);</span><br><span class="line"><span class="comment">//用于否定确认,示己拒绝处理该消息，可以将其丢弃了</span></span><br></pre></td></tr></table></figure><p>第一个参数表示拒绝 <code>deliveryTag</code> 对应的消息，第二个参数是表示否应用于多消息，第三个参数表示是否 <code>requeue</code>，与 basicReject 区别就是同时支持多个消息，可以 拒绝签收 该消费者先前接收未 ack 的所有消息。拒绝签收后的消息也会被自己消费到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel.basicRecover(<span class="type">boolean</span> requeue);</span><br></pre></td></tr></table></figure><p>是否恢复消息到队列，参数是是否 <code>requeue</code>，true 则重新入队列，并且尽可能的将之前 <code>recover</code> 的消息投递给其他消费者消费，而不是自己再次消费。false 则消息会重新被投递给自己。</p><p><strong>消息重新入队</strong>：如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><h4 id="RabbitMQ持久化"><a href="#RabbitMQ持久化" class="headerlink" title="RabbitMQ持久化"></a>RabbitMQ持久化</h4><p>当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化。</strong></p><h5 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h5><p>队列实现持久化需要在声明队列的时候把 durable 参数设置为true，代表开启持久化</p><blockquote><p>如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列</p></blockquote><h5 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h5><p>需要在<strong>消息生产者</strong>发布消息的时候，开启消息的持久化</p><p>在 basicPublish 方法的第二个参数添加这个属性： <code>MessageProperties.PERSISTENT_TEXT_PLAIN</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes());</span><br></pre></td></tr></table></figure><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p><h4 id="队列消息分发"><a href="#队列消息分发" class="headerlink" title="队列消息分发"></a>队列消息分发</h4><p>当队列对应多个消费者时，如何分发消息也是需要考虑的问题。</p><h5 id="轮询分发"><a href="#轮询分发" class="headerlink" title="轮询分发"></a>轮询分发</h5><p>各个消费者以公平的方式挨个从队列获取消息</p><h5 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h5><p>若某个消费者处理消息耗时过大，其他的消费者处理消息很快，但也只能等待，这样系统吞吐量就会下降，于是有了不公平分发。相对于轮询分发的公平分发不同，不公平分发可以根据消费者处理消息的速率，提前设置消息分发的比重，可以将更多的消息分发给处理速率快的消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置不公平分发</span></span><br><span class="line"><span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure><h5 id="预取值分发"><a href="#预取值分发" class="headerlink" title="预取值分发"></a>预取值分发</h5><p>​默认消息的发送是异步发送的，所以在任何时候，channel 上不止只有一个消息来自消费者的手动确认，所以本质上是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小</strong>，<strong>以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过使用 <code>basic.qos</code> 方法设置「预取计数」值来完成的。</p><p>​该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。</p><p>​通常，增加预取将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p><p>​预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/21/c772e9a64ce383bd.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值不等于 1，则代表预取值,预取值为4</span></span><br><span class="line"><span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure><blockquote><p>不公平分发和预取值分发都用到 <code>basic.qos</code> 方法，如果取值为 1，代表不公平分发，取值不为1，代表预取值分发</p></blockquote><h4 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h4><p>生产者将消息发送给RabbitMQ后， 需要MQ返回给生产者【已收到】的确认信息，这样生产者才知道自己的消息已经发送成功。</p><p>发布确认模式默认是没有开启的，如果需要开启需要调用方法<strong>confirmSelect</strong>，每当你要想使用发布确认，都需要在 channel 上调用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel.confirmSelect();<span class="comment">//开启发布确认</span></span><br></pre></td></tr></table></figure><h5 id="发布确认逻辑"><a href="#发布确认逻辑" class="headerlink" title="发布确认逻辑"></a>发布确认逻辑</h5><p>​生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，生产者在信道上发布的消息会被指派一个唯一的ID（从1开始），一旦消息被<strong>投递到所有匹配的队列中后</strong>，broker就会给生产者发送一个确认消息（包含消息的唯一ID），来告诉生产者消息已经到达目的队列。</p><p>​如果消息和队列是持久化的，那么确认消息就会推迟到在<strong>将消息写入磁盘后</strong>发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>​confirm 模式最大的好处在于是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><h5 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h5><p>​这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，<code>waitForConfirmsOrDie(long)</code> 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p><p>​这种确认方式有一个最大的缺点就是：<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p><h5 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h5><p>​单个确认发布方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。</p><h5 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h5><p>​异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都很好，利用了回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功，下面详细讲解异步确认是怎么实现的。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/21/489a6d140e578e07.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息确认回调的函数</span></span><br><span class="line"><span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (deliveryTag,multiple) -&gt;&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;确认的消息:&quot;</span>+deliveryTag);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1.消息的标记</span></span><br><span class="line"><span class="comment">* 2.是否为批量确认</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//消息确认失败回调函数</span></span><br><span class="line">ConfirmCallback nackCallback= (deliveryTag,multiple) -&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;未确认的消息:&quot;</span>+deliveryTag);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备消息的监听器 监听那些消息成功了，哪些消息失败了</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.监听哪些消息成功了</span></span><br><span class="line"><span class="comment"> * 2.监听哪些消息失败了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">channel.addConfirmListener(ackCallback,nackCallback);<span class="comment">//异步通知</span></span><br></pre></td></tr></table></figure><p>实际案例里，将发布的消息存入 Map 里，方便获取。<code>headMap</code> 方法用于将已确认的消息存入新的 Map 缓存区里，然后清除该新缓存区的内容。因为 <code>headMap</code> 方法是浅拷贝，所以清除了缓存区，相当于清除了内容的地址，也就清除了队列的确认的消息。</p><p><strong>如何处理异步未确认消息?</strong></p><p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmMessage3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_COUNT</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">//Ctrl+Shift+U 变大写</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        publishMessageAsync(); <span class="comment">//发布1000个异步发布确认消息，耗时:43ms</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异步发布确认</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//队列的声明</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程安全有序的一个哈希表，适用于高并发的情况下</span></span><br><span class="line"><span class="comment">* 1.轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">* 2.轻松批量删除条目 只要给到序号</span></span><br><span class="line"><span class="comment">* 3.支持高并发(多线程)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long,String&gt; outstandingConfirms=</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息确认回调的函数</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (deliveryTag,multiple) -&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(multiple) &#123;</span><br><span class="line">                <span class="comment">//2.删除掉已经确认的消息 剩下的就是未确认的消息</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; confirmed =</span><br><span class="line">                        outstandingConfirms.headMap(deliveryTag);</span><br><span class="line">                confirmed.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                outstandingConfirms.remove(deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认的消息:&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.消息的标记</span></span><br><span class="line"><span class="comment"> * 2.是否为批量确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//消息确认失败回调函数</span></span><br><span class="line">        ConfirmCallback nackCallback= (deliveryTag,multiple) -&gt;&#123;</span><br><span class="line">            <span class="comment">//3.打印一下未确认的消息都有哪些</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> outstandingConfirms.remove(deliveryTag);</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息是:&quot;</span>+message+<span class="string">&quot;:::未确认的消息tag:&quot;</span>+deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备消息的监听器 监听那些消息成功了，哪些消息失败了</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.监听哪些消息成功了</span></span><br><span class="line"><span class="comment">         * 2.监听哪些消息失败了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.addConfirmListener(ackCallback,nackCallback);<span class="comment">//异步通知</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//批量发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            String message=i+<span class="string">&quot;消息&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line"><span class="comment">//1.此处记录下所有要发送的消息 消息的总和</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(),message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span>+MESSAGE_COUNT+<span class="string">&quot;个异步发布确认消息，耗时:&quot;</span>+(end-begin)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="应答和确认的区别"><a href="#应答和确认的区别" class="headerlink" title="应答和确认的区别"></a>应答和确认的区别</h6><p>应答功能属于消费者，消费完消息告诉 RabbitMQ 已经消费成功。</p><p>发布功能属于生产者，生产消息到 RabbitMQ，RabbitMQ 需要告诉生产者已经收到消息。</p><h4 id="交换机（Exchanges）"><a href="#交换机（Exchanges）" class="headerlink" title="交换机（Exchanges）"></a>交换机（Exchanges）</h4><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p><p>相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><h5 id="Exchanges的类型"><a href="#Exchanges的类型" class="headerlink" title="Exchanges的类型"></a>Exchanges的类型</h5><ul><li><p>**直接(direct)**：处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 abc ，则只有被标记为 abc 的消息才被转发，不会转发 abc.def，也不会转发 dog.ghi，只会转发 abc。</p></li><li><p>**主题(topic)*<em>：将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号 * 匹配不多不少一个词。因此 abc.# 能够匹配到 abc.def.ghi，但是 abc.</em> 只会匹配到 abc.def。</p></li><li><p>**标题(headers)**：不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。在绑定 Queue 与 Exchange 时指定一组键值对；当消息发送到RabbitMQ 时会取到该消息的 headers 与 Exchange 绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 属性是一个键值对，可以是 Hashtable，键值对的值可以是任何类型。而 fanout，direct，topic 的路由键都需要要字符串形式的。</p><p>匹配规则 x-match 有下列两种类型：</p><p>x-match &#x3D; all ：表示所有的键值对都匹配才能接受到消息</p><p>x-match &#x3D; any ：表示只要有键值对匹配就能接受到消息</p></li><li><p>**扇出(fanout)**：不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout 交换机转发消息是最快的。</p></li></ul><h5 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h5><p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有<strong>随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。</p><p>创建临时队列的方式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure><h5 id="绑定-bindings"><a href="#绑定-bindings" class="headerlink" title="绑定(bindings)"></a>绑定(bindings)</h5><p>binding就是交换机和队列之间的桥梁，他告诉我们 exchange 和那个队列进行了绑定关系。</p><p>绑定用参数：routingKey来表示也可称该参数为bindingkey</p><p>创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);</p><h6 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h6><p><img src="https://tt.xtt.ovh/imgs/2023/07/21/0fb87f49ae2face1.png"></p><p>将消息传给所有绑定这个交换机的队列。相当于广播。 </p><h6 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h6><p><img src="https://tt.xtt.ovh/imgs/2023/07/21/364d239a10549cd7.png"></p><p>direct 将消息发送到它绑定的 routingKey 队列中去。</p><p>当然如果 exchange 的绑定类型是direct，<strong>但是它绑定的多个队列的 key 如果都相同</strong>，在这种情况下虽然绑定类型是 direct <strong>但是它表现的就和 fanout 有点类似了</strong>，就跟广播差不多。</p><h6 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h6><p><img src="https://tt.xtt.ovh/imgs/2023/07/21/1aed87ef2ee6dfd5.png"></p><p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是<strong>一个单词列表</strong>，<strong>以点号分隔开</strong>。单词列表最多不能超过 255 个字节。</p><p><strong>注意：</strong></p><ul><li>***(星号)可以代替一个位置**</li><li><strong>#(井号)可以替代零个或多个位置</strong></li></ul><h4 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h4><h5 id="死信概念"><a href="#死信概念" class="headerlink" title="死信概念"></a>死信概念</h5><p>死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，生产者将消息投递到 broker 或者直接到queue 里了，消费者从 queue 取出消息 进行消费，但某些时候由于特定的原因<strong>导致 queue 中的某些消息无法被消费</strong>，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p><p>应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。</p><h5 id="死信来源"><a href="#死信来源" class="headerlink" title="死信来源"></a>死信来源</h5><ul><li><p>消息 TTL 过期</p><p>TTL是 Time To Live 的缩写, 也就是生存时间</p></li><li><p>队列达到最大长度</p><p>队列满了，无法再添加数据到 MQ 中</p></li><li><p>消息被拒绝</p><p>(basic.reject 或 basic.nack) 并且 requeue &#x3D; false</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;RabbitMQ&quot;&gt;&lt;a href=&quot;#RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ&quot;&gt;&lt;/a&gt;RabbitMQ&lt;/h3&gt;&lt;h4 id=&quot;RabbitMQ概念&quot;&gt;&lt;a href=&quot;#Rabbit</summary>
      
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="RabbitMQ" scheme="http://example.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="http://example.com/2023/07/12/Nginx/"/>
    <id>http://example.com/2023/07/12/Nginx/</id>
    <published>2023-07-12T03:24:56.000Z</published>
    <updated>2023-07-23T08:35:43.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><h4 id="什么是Nginx？"><a href="#什么是Nginx？" class="headerlink" title="什么是Nginx？"></a>什么是Nginx？</h4><p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p><p>Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。</p><p>Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。</p><h4 id="Nginx的作用"><a href="#Nginx的作用" class="headerlink" title="Nginx的作用"></a>Nginx的作用</h4><p>Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。</p><p>Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的。</p><h5 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a><strong>正向代理</strong></h5><p>代理客户端发送请求，如加速器等。多对一</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/21/b592584c80fe2dd6.png"></p><h5 id="反向代理"><a href="#反向代理" class="headerlink" title="**反向代理 **"></a>**反向代理 **</h5><p>代理服务端接受客户端的请求。一对多</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/21/3226663c2a29750e.png"></p><p>Nginx 反向代理模块的指令是由 <code>ngx_http_proxy_module</code> 模块进行解析，该模块在安装 Nginx 的时候已经自动加载到 Nginx 中了，接下来我们把反向代理中的常用指令一一介绍下：</p><ul><li>proxy_pass：配置代理的服务器地址</li><li>proxy_set_header：转发给被代理服务器时，设置一些请求头信息</li><li>proxy_redirect：防止客户端可以看到被代理服务器的地址</li></ul><h5 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a><strong>轮询</strong></h5><p>请求以轮询的方式平均的打到不同的服务器上。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/21/def1ee27697c11a6.png"></p><h5 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a><strong>加权轮询</strong></h5><p>不同的服务器有不同的比重，比重高的接受到的请求多。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/21/90767cf42d63e87a.png"></p><h5 id="iphash"><a href="#iphash" class="headerlink" title="iphash"></a><strong>iphash</strong></h5><p>对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/21/046dc8cc13b8e112.png"></p><h5 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a><strong>动静分离</strong></h5><p>在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/21/1b6868550091903d.png"></p><h4 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h4><ol><li>cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;</li><li>.&#x2F;nginx  启动</li><li>.&#x2F;nginx -s quit  安全退出</li><li>.&#x2F;nginx -s stop  停止</li><li>.&#x2F;nginx -s reload  重新加载配置文件</li><li>ps aux|grep nginx  查看nginx进程</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h3&gt;&lt;h4 id=&quot;什么是Nginx？&quot;&gt;&lt;a href=&quot;#什么是Nginx？&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Nginx" scheme="http://example.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>使用docker和minio实现对象存储</title>
    <link href="http://example.com/2023/07/01/%E4%BD%BF%E7%94%A8docker%E5%92%8Cminio%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"/>
    <id>http://example.com/2023/07/01/%E4%BD%BF%E7%94%A8docker%E5%92%8Cminio%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/</id>
    <published>2023-07-01T03:22:41.000Z</published>
    <updated>2023-07-23T09:03:28.633Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="使用docker和minio实现对象存储"><a href="#使用docker和minio实现对象存储" class="headerlink" title="使用docker和minio实现对象存储"></a>使用docker和minio实现对象存储</h3><h4 id="什么是minio"><a href="#什么是minio" class="headerlink" title="什么是minio"></a>什么是minio</h4><p>​<strong>Minio</strong>是一个开源的<code>分布式文件存储</code>系统，它基于 Golang 编写,虽然<strong>轻量</strong>，却拥有着不错的<strong>高性能</strong>，可以将图片、视频、音乐、pdf这些文件存储到多个主机，可以存储到多个Linux，或者多个Windows，或者多个Mac，Minio中存储<strong>最大文件</strong>可以达到<code>5TB</code>。</p><p>​<strong>任何类型</strong>的文件都是<code>支持</code>的，主要应用在<code>微服务</code>系统中。</p><h4 id="安装minio"><a href="#安装minio" class="headerlink" title="安装minio"></a>安装minio</h4><p>​这里我们使用docker来安装minio镜像，然后通过minio镜像来创建一个minio容器。不了解docker的可以移步这里。</p><blockquote><p>docker pull minio&#x2F;minio    # 拉取最新版本的minio镜像</p><p>docker run -p 9000:9000 -p 9090:9090     –net&#x3D;host    –name minio-6    -d –restart&#x3D;always      -e “MINIO_ACCESS_KEY&#x3D;minioadmin”      -e “MINIO_SECRET_KEY&#x3D;minioadmin”      -v &#x2F;home&#x2F;minio&#x2F;data:&#x2F;data      -v &#x2F;home&#x2F;minio&#x2F;config:&#x2F;root&#x2F;.minio      minio&#x2F;minio  server    &#x2F;data   –console-address “:9090” -address “:9000”</p><p>参数解释</p><p>-p 映射端口，–restart&#x3D;always自启动，-d后台启动</p><p>–console-address， –addressminio默认启动是动态端口,设置固定端口</p><p>-v &#x2F;home&#x2F;minio&#x2F;data:&#x2F;data   -v &#x2F;home&#x2F;minio&#x2F;config:&#x2F;root&#x2F;.minio  数据卷挂载，是minio数据存储的位置</p><p>MINIO_ACCESS_KEY&#x3D;minioadmin 用户名</p><p>MINIO_SECRET_KEY&#x3D;minioadmin 密码</p></blockquote><h4 id="使用minio"><a href="#使用minio" class="headerlink" title="使用minio"></a>使用minio</h4><p>访问     公网ip:9090&#x2F;login      即可进入minio登录页面(本地测试可用localhost:9090&#x2F;login)</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/ffa5f37902554ffd.png"></p><p>账号密码是一开始运行时我们自己设置的。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/afc753c6bf9faaa2.png"></p><p>一开始没有任何桶，我们可以创建一个新的存储桶。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/e4f33f80866ad0aa.png"></p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/585b7a497fc09cbc.png"></p><p>创建成功后就会显示我们刚刚创建的存储桶，我们点进去查看。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/37c09953f028cc49.png"></p><p>存储桶一开始默认权限为私有，让他其他人访问文件需要修改权限为public公开！</p><p>但是仅仅将存储桶的权限修改还是不能访问，还需要将linux系统中的文件权限给放开，这里我偷了懒，将存储桶所在的文件夹设置为所有用户拥有所有权限。</p><blockquote><p>sudo chmod -R 777  minio  修改文件夹下所有文件的权限为所有人都有读和写以及执行的权限</p></blockquote><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/7b018e515356b372.png"></p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/0b3ad64218393876.png"></p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/51a6eef264765c98.png"></p><p>点击分享可以设置url时限，但是使用   <strong>公网ip:9000&#x2F;存储桶名称&#x2F;文件名</strong>   可永久访问（即有时限url的前面一部分）</p><p>以上步骤便可使用minio实现对象存储，如有错误，欢迎指正。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;使用docker和minio实现对象存储&quot;&gt;&lt;a href=&quot;#使用docker和minio实现对象存储&quot; class=&quot;headerlink&quot; title=&quot;使用docker和minio实现对象存储&quot;&gt;&lt;/a&gt;使用docker和mini</summary>
      
    
    
    
    <category term="docker" scheme="http://example.com/categories/docker/"/>
    
    
    <category term="minio" scheme="http://example.com/tags/minio/"/>
    
  </entry>
  
  <entry>
    <title>Springboot整合第三方登录</title>
    <link href="http://example.com/2023/06/18/Java%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"/>
    <id>http://example.com/2023/06/18/Java%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</id>
    <published>2023-06-18T03:24:56.000Z</published>
    <updated>2023-07-23T09:11:05.907Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Springboot整合第三方登录"><a href="#Springboot整合第三方登录" class="headerlink" title="Springboot整合第三方登录"></a>Springboot整合第三方登录</h3><h4 id="为什么采用第三方登录"><a href="#为什么采用第三方登录" class="headerlink" title="为什么采用第三方登录"></a>为什么采用第三方登录</h4><p>​采用第三方登录可以避免重新注册账号的繁琐，也不需要再为密码和昵称发愁，而第三方登录有一个比较好用的包，里面整合了多种第三方登录，开箱即用，非常方便。就是JustAuth，网址<a href="https://www.justauth.cn/%E3%80%82">https://www.justauth.cn/。</a></p><h4 id="整合第三方登录"><a href="#整合第三方登录" class="headerlink" title="整合第三方登录"></a>整合第三方登录</h4><h5 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h5><p>​这里采用gitee进行测试，因为gitee不需要其他的东西，只需要你有一个账号就可以。注册一个gitee账号后，到这里(<a href="https://gitee.com/oauth/applications)%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E3%80%82">https://gitee.com/oauth/applications)创建一个应用。</a></p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/78d10ea0780d73c7.png"></p><ul><li><p><strong>应用名称</strong>，这个根据自己的需要填，我测试使用就填了一个测试demo1</p></li><li><p><strong>应用描述</strong>可填可不填</p></li><li><p><strong>应用主页</strong>需要填一个已经上线的项目地址（这个不一定要填自己的项目，因为既然要整和第三方登录，那项目大概率是没上线的，这里可以随便填一个可用的网址，某度什么的都可以）</p></li><li><p><strong>应用回调地址</strong>这个不能随便填，这个地址是之后用户授权后的回调地址，这是我测试时填的<a href="http://localhost:8080/oauth/callback">http://localhost:8080/oauth/callback</a></p></li><li><p><strong>权限</strong> 根据页面提示操作，默认勾选第一个就行</p></li></ul><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/e9b3da03130dc937.png"></p><p>创建成功后，可以在我的应用里面找到这个应用，里面的ClientID和ClientSecret是待会要用到的。</p><h5 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入第三方登录依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>me.zhyd.oauth<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>JustAuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入处理json依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="创建controller类"><a href="#创建controller类" class="headerlink" title="创建controller类"></a>创建controller类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> me.zhyd.oauth.config.AuthConfig;</span><br><span class="line"><span class="keyword">import</span> me.zhyd.oauth.request.AuthGiteeRequest;</span><br><span class="line"><span class="keyword">import</span> me.zhyd.oauth.model.AuthCallback;</span><br><span class="line"><span class="keyword">import</span> me.zhyd.oauth.request.AuthRequest;</span><br><span class="line"><span class="keyword">import</span> me.zhyd.oauth.utils.AuthStateUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/oauth&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestAuthController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/render&quot;)</span><span class="comment">//调用此接口来进行授权认证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">renderAuth</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">AuthRequest</span> <span class="variable">authRequest</span> <span class="operator">=</span> getAuthRequest();</span><br><span class="line">        response.sendRedirect(authRequest.authorize(AuthStateUtils.createState()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/callback&quot;)</span></span><br><span class="line">    <span class="comment">//授权认证成功后会自动调用此接口，这个接口是创建应用时填写的回调接口</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">login</span><span class="params">(AuthCallback callback)</span> &#123;</span><br><span class="line">        <span class="comment">//可以对对象进行操作，比如取出里面得名称跟邮箱信息等等</span></span><br><span class="line">        <span class="comment">//我这里取出了昵称和邮箱</span></span><br><span class="line">        <span class="type">AuthRequest</span> <span class="variable">authRequest</span> <span class="operator">=</span> getAuthRequest();</span><br><span class="line">        <span class="type">AuthResponse</span> <span class="variable">login</span> <span class="operator">=</span> authRequest.login(callback);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">remoteData</span> <span class="operator">=</span> JSONObject.parseObject(JSON.toJSONString(login));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">gitEEUser</span> <span class="operator">=</span> remoteData.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">user</span> <span class="operator">=</span> JSONObject.parseObject(JSON.toJSONString(gitEEUser));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">nickname</span> <span class="operator">=</span> user.get(<span class="string">&quot;nickname&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">email</span> <span class="operator">=</span> user.get(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">        HashMap&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;nickname&quot;</span>,nickname);</span><br><span class="line">        map.put(<span class="string">&quot;email&quot;</span>,email);</span><br><span class="line">        <span class="comment">//TODO 数据库操作</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AuthRequest <span class="title function_">getAuthRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthGiteeRequest</span>(AuthConfig.builder()</span><br><span class="line">                .clientId(<span class="string">&quot;Client ID&quot;</span>)<span class="comment">//这些参数按自己的填即可</span></span><br><span class="line">                .clientSecret(<span class="string">&quot;Client Secret&quot;</span>)</span><br><span class="line">                .redirectUri(<span class="string">&quot;应用回调地址&quot;</span>)<span class="comment">//这就是上面的那个接口地址，也是创建应用时写的那个</span></span><br><span class="line">                .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试访问  localhost:8080&#x2F;oauth&#x2F;rander  接口，授权认证后，显示昵称和邮箱</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/b522090460b283e5.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;Springboot整合第三方登录&quot;&gt;&lt;a href=&quot;#Springboot整合第三方登录&quot; class=&quot;headerlink&quot; title=&quot;Springboot整合第三方登录&quot;&gt;&lt;/a&gt;Springboot整合第三方登录&lt;/h3&gt;</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="第三方登录" scheme="http://example.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java实现文件分片上传</title>
    <link href="http://example.com/2023/06/11/Java%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
    <id>http://example.com/2023/06/11/Java%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0/</id>
    <published>2023-06-11T03:24:56.000Z</published>
    <updated>2023-07-23T09:11:45.832Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Java实现文件分片上传"><a href="#Java实现文件分片上传" class="headerlink" title="Java实现文件分片上传"></a>Java实现文件分片上传</h3><h4 id="为什么要使用分片上传"><a href="#为什么要使用分片上传" class="headerlink" title="为什么要使用分片上传"></a>为什么要使用分片上传</h4><p>在需要上传文件时，不可避免地会遇到上传文件内容过大，上传时间太长地问题，采用文件分片上传就可以解决这个问题。</p><h4 id="什么是分片上传？"><a href="#什么是分片上传？" class="headerlink" title="什么是分片上传？"></a>什么是分片上传？</h4><p>简单的说就是本来是需要一次搬一个很大的东西，比如是一大桶水，一次搬起来比较费事费力。我们可以把这一大桶水分装在几个或几十个或者更多的小瓶里，这样搬运起来就比较省力，也比较方便，等到目的地后，我们在将这些小瓶子里的水都倒回大桶里，这样就完成了一大桶水的搬运工作。这个将一大桶水分成许多小瓶子的过程就是分片的过程，最后将水倒回大桶的过程就是合并的过程。分片与合并也是文件分片上传的重要过程。</p><h4 id="前后端代码"><a href="#前后端代码" class="headerlink" title="前后端代码"></a>前后端代码</h4><p>这个分片的过程是在前端实现的，上传完成后的合并工作是后端完成的。</p><p>前端代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS分片上传-极速上传<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;slice&quot;</span> <span class="attr">id</span>=<span class="string">&quot;slice&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://libs.baidu.com/jquery/1.8.3/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&quot;#slice&quot;</span>).<span class="title function_">change</span>(<span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> file = $(<span class="string">&quot;#slice&quot;</span>)[<span class="number">0</span>].<span class="property">files</span>[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">PostFile</span>(file,<span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//执行分片上传</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">PostFile</span>(<span class="params">file,i, uuid</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> name = file.<span class="property">name</span>,                           <span class="comment">//文件名</span></span></span><br><span class="line"><span class="language-javascript">            size = file.<span class="property">size</span>,                           <span class="comment">//总大小</span></span></span><br><span class="line"><span class="language-javascript">            shardSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>,                <span class="comment">//以10MB为一个分片,每个分片的大小</span></span></span><br><span class="line"><span class="language-javascript">            shardCount = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(size / shardSize);   <span class="comment">//总片数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(i &gt;= shardCount)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//判断uuid是否存在</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (uuid === <span class="literal">null</span> || uuid === <span class="literal">undefined</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            uuid = <span class="title function_">guid</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//console.log(size,i+1,shardSize);  //文件总大小，第一次，分片大小//</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> start = i * shardSize;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> end = start + shardSize;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> packet = file.<span class="title function_">slice</span>(start, end);  <span class="comment">//将文件进行切片</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/*  构建form表单进行提交  */</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> form = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span></span><br><span class="line"><span class="language-javascript">        form.<span class="title function_">append</span>(<span class="string">&quot;uuid&quot;</span>, uuid);<span class="comment">// 前端生成uuid作为标识符传个后台每个文件都是一个uuid防止文件串了</span></span></span><br><span class="line"><span class="language-javascript">        form.<span class="title function_">append</span>(<span class="string">&quot;data&quot;</span>, packet); <span class="comment">//slice方法用于切出文件的一部分</span></span></span><br><span class="line"><span class="language-javascript">        form.<span class="title function_">append</span>(<span class="string">&quot;name&quot;</span>, name);</span></span><br><span class="line"><span class="language-javascript">        form.<span class="title function_">append</span>(<span class="string">&quot;totalSize&quot;</span>, size);</span></span><br><span class="line"><span class="language-javascript">        form.<span class="title function_">append</span>(<span class="string">&quot;total&quot;</span>, shardCount); <span class="comment">//总片数</span></span></span><br><span class="line"><span class="language-javascript">        form.<span class="title function_">append</span>(<span class="string">&quot;index&quot;</span>, i + <span class="number">1</span>); <span class="comment">//当前是第几片</span></span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>: <span class="string">&quot;http://127.0.0.1:8080/index/doPost&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: form,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//timeout:&quot;10000&quot;,  //超时10秒</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">async</span>: <span class="literal">true</span>, <span class="comment">//异步</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">processData</span>: <span class="literal">false</span>, <span class="comment">//很重要，告诉jquery不要对form进行处理</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">contentType</span>: <span class="literal">false</span>, <span class="comment">//很重要，指定为false才能形成正确的Content-Type</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">msg</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">/*  表示上一块文件上传成功，继续下一次  */</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (msg.<span class="property">status</span> === <span class="number">201</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    form = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                    i++;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title class_">PostFile</span>(file, i, uuid);</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.<span class="property">status</span> === <span class="number">502</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    form = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">/*  失败后，每2秒继续传一次分片文件  */</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title class_">PostFile</span>(file, i, uuid) &#125;, <span class="number">2000</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.<span class="property">status</span> === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">merge</span>(uuid, name)</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;上传成功&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.<span class="property">status</span> === <span class="number">500</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第&#x27;</span>+msg.<span class="property">i</span>+<span class="string">&#x27;次，上传文件有误！&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;未知错误&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">uuid, fileName</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>: <span class="string">&quot;http://127.0.0.1:8080/index/merge&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&quot;GET&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;<span class="attr">uuid</span>: uuid, <span class="attr">newFileName</span>: fileName&#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//timeout:&quot;10000&quot;,  //超时10秒</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">async</span>: <span class="literal">true</span>, <span class="comment">//异步</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">msg</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">guid</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="string">&#x27;xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/[xy]/g</span>, <span class="keyword">function</span> (<span class="params">c</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> r = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">16</span> | <span class="number">0</span>,</span></span><br><span class="line"><span class="language-javascript">                v = c === <span class="string">&#x27;x&#x27;</span> ? r : (r &amp; <span class="number">0x3</span> | <span class="number">0x8</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> v.<span class="title function_">toString</span>(<span class="number">16</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartHttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test_controller</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileUploadTempDir</span> <span class="operator">=</span> <span class="string">&quot;D:/portalupload/fileuploaddir&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileUploadDir</span> <span class="operator">=</span> <span class="string">&quot;D:/portalupload/file&quot;</span>;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/doPost&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Map <span class="title function_">fragmentation</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class="line">        resp.addHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">MultipartHttpServletRequest</span> <span class="variable">multipartRequest</span> <span class="operator">=</span> (MultipartHttpServletRequest) req;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得文件分片数据</span></span><br><span class="line">        <span class="type">MultipartFile</span> <span class="variable">file</span> <span class="operator">=</span> multipartRequest.getFile(<span class="string">&quot;data&quot;</span>);</span><br><span class="line"><span class="comment">//        分片第几片</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.parseInt(multipartRequest.getParameter(<span class="string">&quot;index&quot;</span>));</span><br><span class="line"><span class="comment">//        总片数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> Integer.parseInt(multipartRequest.getParameter(<span class="string">&quot;total&quot;</span>));</span><br><span class="line"><span class="comment">//        获取文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> multipartRequest.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> fileName.substring(<span class="number">0</span>, fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileEnd</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"><span class="comment">//        前端uuid，作为标识</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> multipartRequest.getParameter(<span class="string">&quot;uuid&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">uploadFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileUploadTempDir + <span class="string">&quot;/&quot;</span> + uuid, uuid + name + index + <span class="string">&quot;.tem&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!uploadFile.getParentFile().exists()) &#123;</span><br><span class="line">            uploadFile.getParentFile().mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; total) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                file.transferTo(uploadFile);</span><br><span class="line">                <span class="comment">// 上传的文件分片名称</span></span><br><span class="line">                map.put(<span class="string">&quot;status&quot;</span>, <span class="number">201</span>);</span><br><span class="line">                <span class="keyword">return</span> map;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                map.put(<span class="string">&quot;status&quot;</span>, <span class="number">502</span>);</span><br><span class="line">                <span class="keyword">return</span> map;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                file.transferTo(uploadFile);</span><br><span class="line">                <span class="comment">// 上传的文件分片名称</span></span><br><span class="line">                map.put(<span class="string">&quot;status&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                <span class="keyword">return</span> map;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                map.put(<span class="string">&quot;status&quot;</span>, <span class="number">502</span>);</span><br><span class="line">                <span class="keyword">return</span> map;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/merge&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Map <span class="title function_">merge</span><span class="params">(String uuid, String newFileName)</span> &#123;</span><br><span class="line">        System.out.println(newFileName);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">retMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">dirFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileUploadTempDir + <span class="string">&quot;/&quot;</span> + uuid);</span><br><span class="line">            <span class="keyword">if</span> (!dirFile.exists()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件不存在！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//分片上传的文件已经位于同一个文件夹下，方便寻找和遍历（当文件数大于十的时候记得排序用冒泡排序确保顺序是正确的）</span></span><br><span class="line">            String[] fileNames = dirFile.list();</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> newFileName.substring(<span class="number">0</span>, newFileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">            Arrays.sort(fileNames, (o1,o2)-&gt;&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.parseInt(o1.substring(o1.indexOf(name)+name.length()).split(<span class="string">&quot;\\.tem&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.parseInt(o2.substring(o2.indexOf(name)+name.length()).split(<span class="string">&quot;\\.tem&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> i1 - i2;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//       创建空的合并文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileUploadDir, newFileName);</span><br><span class="line">            <span class="keyword">if</span> (!targetFile.getParentFile().exists()) &#123;</span><br><span class="line">                targetFile.getParentFile().mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">RandomAccessFile</span> <span class="variable">writeFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(targetFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (String fileName : fileNames) &#123;</span><br><span class="line">                System.out.println(fileName);</span><br><span class="line">                <span class="type">File</span> <span class="variable">sourceFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileUploadTempDir + <span class="string">&quot;/&quot;</span> + uuid, fileName);</span><br><span class="line">                <span class="type">RandomAccessFile</span> <span class="variable">readFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(sourceFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">chunksize</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">3</span>;</span><br><span class="line">                <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[chunksize];</span><br><span class="line">                writeFile.seek(position);</span><br><span class="line">                <span class="type">int</span> byteCount;</span><br><span class="line">                <span class="keyword">while</span> ((byteCount = readFile.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (byteCount != chunksize) &#123;</span><br><span class="line">                        <span class="type">byte</span>[] tempBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[byteCount];</span><br><span class="line">                        System.arraycopy(buf, <span class="number">0</span>, tempBytes, <span class="number">0</span>, byteCount);</span><br><span class="line">                        buf = tempBytes;</span><br><span class="line">                    &#125;</span><br><span class="line">                    writeFile.write(buf);</span><br><span class="line">                    position = position + byteCount;</span><br><span class="line">                &#125;</span><br><span class="line">                readFile.close();</span><br><span class="line">                FileUtils.deleteQuietly(sourceFile);<span class="comment">//删除缓存的临时文件</span></span><br><span class="line">            &#125;</span><br><span class="line">            writeFile.close();</span><br><span class="line">            retMap.put(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;200&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            retMap.put(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;500&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/d45627e0f27b9892.png"></p><p>可以看到文件进行了分片上传，我是上传了一个系统镜像文件，4GB多，上传的也是非常的快。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;Java实现文件分片上传&quot;&gt;&lt;a href=&quot;#Java实现文件分片上传&quot; class=&quot;headerlink&quot; title=&quot;Java实现文件分片上传&quot;&gt;&lt;/a&gt;Java实现文件分片上传&lt;/h3&gt;&lt;h4 id=&quot;为什么要使用分片上传&quot;&gt;</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="分片上传" scheme="http://example.com/tags/%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>Docker的简单使用</title>
    <link href="http://example.com/2023/05/30/Docker%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/05/30/Docker%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2023-05-30T03:24:56.000Z</published>
    <updated>2023-07-23T09:08:23.266Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Docker的简单使用"><a href="#Docker的简单使用" class="headerlink" title="Docker的简单使用"></a>Docker的简单使用</h3><h4 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h4><p>​Docker 是一个应用打包、分发、部署的工具。你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。</p><p>​Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。</p><h4 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h4><h5 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h5><p>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像&#x3D;&#x3D;&#x3D;&gt;run&#x3D;&#x3D;&gt;tomcat01容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。</p><h5 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h5><p>Docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的。<br>启动，停止，删除，基本命令！<br>目前就可以把这个容器理解为就是一个简易的linux系统</p><h5 id="仓库（repository）"><a href="#仓库（repository）" class="headerlink" title="仓库（repository）"></a>仓库（repository）</h5><p>仓库就是存放镜像的地方！<br>仓库分为公有仓库和私有仓库！<br>Docker Hub（默认是国外的）阿里云.…都有容器服务器（配置镜像加速！）</p><h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><p>docker要求系统内核是3.10以上，可以使用uname -r命令来查看系统内核发行版本号。</p><blockquote><p> 1.卸载旧的版本</p><p>yum remove docker <br>                  docker-client <br>                  docker-client-latest <br>                  docker-common <br>                  docker-latest <br>                  docker-latest-logrotate <br>                  docker-logrotate <br>                  docker-engine</p></blockquote><blockquote><p>2.需要的安装包</p><p>yum install -y yum-utils</p><p>3.设置镜像的仓库</p><p>yum-config-manager <br>    –add-repo <br>    <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a> # 使用阿里云镜像</p><p>安装容器之前，更新yum软件包索引。</p><p>yum makecache fast</p><p>4.安装容器相关的。docker-ce（社区版）docker-ee（企业版）</p><p>yum install docker-ce docker-ce-cli containerd.io</p><p>5.启动docker</p><p>systemctl start docker</p><p>6.使用docker version查看是否安装成功</p><p>docker version</p></blockquote><h4 id="卸载docker"><a href="#卸载docker" class="headerlink" title="卸载docker"></a>卸载docker</h4><blockquote><p>1.卸载依赖</p><p>yum remove docker-ce docker-ce-cli containerd.io</p></blockquote><blockquote><p>2.删除资源</p><p>rm -rf &#x2F;var&#x2F;lib&#x2F;docker<br>rm -rf &#x2F;var&#x2F;lib&#x2F;containerd</p></blockquote><h4 id="配置docker镜像加速"><a href="#配置docker镜像加速" class="headerlink" title="配置docker镜像加速"></a>配置docker镜像加速</h4><blockquote><ol><li><p>sudo mkdir -p &#x2F;etc&#x2F;docker</p></li><li><p>sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-‘EOF’<br> {<br> “registry-mirrors”: [“<a href="https://docker.mirrors.ustc.edu.cn"]">https://docker.mirrors.ustc.edu.cn&quot;]</a><br> }<br> EOF</p><p> &#x2F;&#x2F;中国科学技术大学镜像</p></li><li><p>sudo systemctl daemon-reload</p></li><li><p>sudo systemctl restart docker</p></li></ol></blockquote><h4 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h4><blockquote><p>docker 命令 –help         # 帮助命令</p></blockquote><blockquote><p>#查看所有本地的主机上的镜像<br>dokcer images<br>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE<br>hello-world   latest    feb5d9fea6a5   10 months ago   13.3kB</p><p>解释</p><p>REPOSITORY    镜像的仓库源<br>TAG            镜像的标签<br>IMAGE ID    镜像的id<br>CREATED        镜像的创建时间<br>SIZE        镜像的大小</p><p>命令参数可选项</p><p> -a, –all         # 显示所有镜像 (docker images -a)<br> -q, –quiet       # 仅显示镜像id (docker images -q)</p></blockquote><blockquote><p>搜索镜像</p><p>docker search  镜像名</p></blockquote><blockquote><p>下载镜像</p><p>docker pull  镜像名[:版本号]</p><p>可以指定版本，不指定默认下载最新版，docker下载是分层下载，可以实现层级复用</p></blockquote><blockquote><p>删除镜像</p><p>docker rmi   -f 镜像id  # 删除指定的镜像</p><p>docker rmi -f 镜像id 镜像id 镜像id    # 删除多个镜像（空格分隔）</p><p>docker rmi -f $(docker images -aq)    # 删除全部的镜像</p></blockquote><blockquote><p>新建容器并启动</p><p>docker run [可选参数] image</p><blockquote><p>-d 后台启动</p><blockquote><p>常见的坑：docker容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止。</p><p>比如：nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</p></blockquote><p>–name  指定容器名字</p><p>-it 使用交互方式运行：进入容器内查看内容</p><blockquote><p>exit 关闭容器并从容器中退出</p><p>ctrl+P+Q 不关闭容器退出容器</p></blockquote><p>-p 指定容器的端口（小写p）</p><p>-P 随机指定端口（大写p）</p></blockquote></blockquote><blockquote><p>进入正在运行的容器</p><p>docker exec -it 容器id &#x2F;bin&#x2F;bash</p></blockquote><blockquote><p>退出容器</p><p>exit        # 容器直接停止，并退出</p><p>ctrl+p+q   容器不停止退出</p></blockquote><blockquote><p>列出当前正在运行的容器</p><p>docker ps </p><blockquote><p>-a    # 列出当前正在运行的容器+历史运行过的容器</p><p>-q    # 只显示容器的编号</p><p>-n&#x3D;？  # 显示最近创建的容器（可以指定显示几条，比如-n&#x3D;1）</p></blockquote></blockquote><blockquote><p>删除容器</p><p>docker  rm  容器id   # 不能删除正在运行的容器</p><p>docker rm -f 容器id   # 强制删除，包括正在运行的容器</p><p>docker  rm  -f  $(docker ps -aq)     #删除所有容器</p><p>docker  rm  -f  -q|xargs  docker  rm    #删除所有容器</p></blockquote><blockquote><p> 启动和停止容器</p><p>docker  start  容器id    #启动容器</p><p>docker restart 容器id   # 重启容器</p><p>docker stop 容器id       # 停止当前正在运行的容器</p><p>docker kill 容器id        # 强制停止当前容器</p></blockquote><blockquote><p>从容器内拷贝文件到主机上</p><p>docker cp 容器id:容器内路径 目的主机的路径</p></blockquote><blockquote><p>查看镜像的元数据</p><p>docker inspect 容器id</p></blockquote><h4 id="docker安装nginx（docker简单使用）"><a href="#docker安装nginx（docker简单使用）" class="headerlink" title="docker安装nginx（docker简单使用）"></a>docker安装nginx（docker简单使用）</h4><p>docker pull nginx 下载nginx镜像</p><p>docker run -d –name&#x3D;”nginx-1” -p 3344:80 nginx   启动nginx</p><p># -d 后台运行</p><p># –name&#x3D;”nginx01”    给容器命名</p><p># -p 宿主机端口:容器内部端口</p><p>测试访问 : 访问宿主机公网ip:宿主机端口</p><p>出现以下页面即为成功！</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/d480dd172ba1dda9.jpg"></p><p>失败可能的原因，云服务器未暴露3344端口（以我容器端口号为例）。</p><h4 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h4><h5 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h5><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。<br>所有的应用，直接打包docker镜像，就可以直接跑起来！<br>如何得到镜像：</p><ul><li>从远程仓库下载</li><li>朋友拷贝给你</li><li>自己制作一个镜像DockerFile</li></ul><h5 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h5><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union 文件系统是Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h5 id="Docker镜像加载原型"><a href="#Docker镜像加载原型" class="headerlink" title="Docker镜像加载原型"></a>Docker镜像加载原型</h5><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就是UnionFS。</p><p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs（root file system），在bootfs之上。包含的就是典型Linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准目录和文件。<br>rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p><p>对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。</p><h5 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h5><p>所有的Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。<br>举一个简单的例子，假如基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。</p><p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！<br>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p><h4 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h4><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接使用命令来挂载：-v</span></span><br><span class="line">docker run -it -v 主机目录:容器内目录 镜像名 /bin/bash</span><br></pre></td></tr></table></figure><p>好处：我们以后修改只需要在本地修改即可，容器内会自动同步！</p><h5 id="匿名和具名挂载"><a href="#匿名和具名挂载" class="headerlink" title="匿名和具名挂载"></a>匿名和具名挂载</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如何确定是具名挂载，还是匿名挂载，还是指定路径挂载</span></span><br><span class="line">-v 容器内的路径  # 匿名挂载：我们在-v挂载目录时，只写了容器内的路径，没有写容器外的路径。</span><br><span class="line">-v 卷名:容器内的路径    # 具名挂载</span><br><span class="line">-v /宿主机路径:容器内路径  # 指定路径挂载</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 -v 容器内的路径:ro    rw    改变读写权限</span></span><br><span class="line">ro    read only    # 只读</span><br><span class="line">rw    read write    # 可读可写</span><br><span class="line"></span><br><span class="line">docker volume create es-plugins#创建一个数据卷</span><br><span class="line">docker volume inspect es-plugins#查看具名挂在的路径</span><br><span class="line">docker logs -f es   #查看日志</span><br></pre></td></tr></table></figure><h4 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h4><p>介绍：</p><p>dockerfile是用来构建docker镜像的文件！命令参数脚本！<br>构建步骤：<br>1、编写一个dockerfile文件<br>2、docker build 构建成为一个镜像<br>3、docker run运行镜像<br>4、docker push发布镜像（DockerHub、阿里云镜像仓库！）</p><p>注意：</p><p>1、每个保留关键字（指令）都是必须是大写字母<br>2、执行从上到下顺序执行<br>3、# 表示注释<br>4、每一个指令都会创建提交一个新的镜像层，并提交！</p><h5 id="DockerFile命令"><a href="#DockerFile命令" class="headerlink" title="DockerFile命令"></a>DockerFile<strong>命令</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM        # 基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER    # 镜像是谁写的：姓名+邮箱</span><br><span class="line">RUN            # 镜像构建的时候需要运行的命令</span><br><span class="line">ADD            # 步骤：tomcat镜像，这个tomcat压缩包！添加内容</span><br><span class="line">WORKDIR        # 镜像的工作目录</span><br><span class="line">VOLUME        # 挂载的目录</span><br><span class="line">EXPOSE        # 暴露端口配置</span><br><span class="line">CMD            # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT    # 指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class="line">ONBUILD        # 当构建一个被继承DockerFile这个时候就会运行ONBUILD的指令。触发指令。</span><br><span class="line">COPY        # 类似ADD，将我们文件拷贝到镜像中</span><br><span class="line">ENV            # 构建的时候设置环境变量！</span><br></pre></td></tr></table></figure><blockquote><p> CMD和ENTRYPOINT的区别</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMD            # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT     # 指定这个容器启动的时候要运行的命令，可以追加命令</span><br></pre></td></tr></table></figure><h4 id="使用Docker搭建ES"><a href="#使用Docker搭建ES" class="headerlink" title="使用Docker搭建ES"></a>使用Docker搭建ES</h4><p>拉镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:7.14.0</span><br></pre></td></tr></table></figure><p>创建容器并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name es -p 9200:9200 -p 9300:9300 -v /usr/local/docker/es/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /usr/local/docker/es/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \</span><br><span class="line">elasticsearch:7.14.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用该语句</span></span><br><span class="line">docker run -d --name es -p 9200:9200 -p 9300:9300 -v /usr/local/docker/es/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v es-data:/usr/share/elasticsearch/data \</span><br><span class="line">-v es-plugins:/usr/share/elasticsearch/plugins -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot;  elasticsearch:7.14.0</span><br></pre></td></tr></table></figure><p>配置允许跨域</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入es容器内部</span></span><br><span class="line">docker exec -it es bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改es的配置文件</span></span><br><span class="line">vi /usr/share/elasticsearch/config/elasticsearch.yml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">原有配置</span></span><br><span class="line">cluster.name: &quot;docker-cluster&quot;</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加配置</span></span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><p>下载分词器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.14.0/elasticsearch-analysis-ik-7.14.0.zip</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">与es版本需要对应</span></span><br><span class="line">选择合适的版本：https://github.com/medcl/elasticsearch-analysis-ik/releases</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压到ik目录下</span></span><br><span class="line">unzip elasticsearch-analysis-ik-7.14.0.zip -d ./ik/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将ik文件夹<span class="built_in">cp</span>到es容器中</span></span><br><span class="line">docker cp ./ik/ es:/usr/share/elasticsearch/plugins/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启es</span></span><br><span class="line">docker restart es</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">校验es</span></span><br><span class="line">curl localhost:9200</span><br></pre></td></tr></table></figure><p>存储数据挂载未配置，分词未测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器名称或id:容器内文件地址 本机地址</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不知道为什么复制文件到本机变成了文件夹</span></span><br></pre></td></tr></table></figure><p>ik分词器包含两种模式：</p><ul><li>ik_smart:最少切分</li><li>ik_max_word:最细切分</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;Docker的简单使用&quot;&gt;&lt;a href=&quot;#Docker的简单使用&quot; class=&quot;headerlink&quot; title=&quot;Docker的简单使用&quot;&gt;&lt;/a&gt;Docker的简单使用&lt;/h3&gt;&lt;h4 id=&quot;Docker-是什么&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="docker" scheme="http://example.com/categories/docker/"/>
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>JUC之手写一个简单的线程池</title>
    <link href="http://example.com/2023/05/20/JUC%E4%B9%8B%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2023/05/20/JUC%E4%B9%8B%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2023-05-20T03:24:56.000Z</published>
    <updated>2023-07-23T08:30:33.858Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="JUC之手写一个简单的线程池"><a href="#JUC之手写一个简单的线程池" class="headerlink" title="JUC之手写一个简单的线程池"></a>JUC之手写一个简单的线程池</h3><p>​在之前介绍了线程池的快捷创建方式以及其中的隐患，紧接着介绍了线程池的标准创建方式，了解了线程池的基本构造后，我们可以自己尝试手写一个简单的线程池来加深我们对线程池的理解。 </p><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>​首先我们需要一个阻塞队列，用来存放任务，可以向其中添加任务，获取其中的任务，还要实现当队列为空时，不能获取任务，当队列已满时，不能向其中添加任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义阻塞队列类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueueTest</span>&lt;T&gt; &#123;</span><br><span class="line">    java.util.logging.Logger logger= getLogger(<span class="string">&quot;BlockingQueueTest&quot;</span>);</span><br><span class="line">    <span class="comment">// 1. 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;T&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 2. 锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 3. 生产者条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">addCon</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// 4. 消费者条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">delCon</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// 5. 队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，指定队列的最大容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueueTest</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.len = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断阻塞队列是否已满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTrue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size()==len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞获取队列中的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(deque.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    delCon.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> deque.getFirst();</span><br><span class="line">            deque.removeFirst();</span><br><span class="line">            addCon.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有超时时间的阻塞获取队列中的任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(Long time, TimeUnit timeUnit)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将等待时间统一转换为纳秒</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> timeUnit.toNanos(time);</span><br><span class="line">            <span class="keyword">while</span>(deque.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nanos &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//返回的值为等待一段时间后剩余的时间</span></span><br><span class="line">                    nanos = delCon.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> deque.getFirst();</span><br><span class="line">            deque.removeFirst();</span><br><span class="line">            addCon.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞添加任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T task)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(deque.size()==len)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    logger.log(Level.INFO,task+<span class="string">&quot;等待加入任务队列---------&quot;</span>);</span><br><span class="line">                    addCon.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.log(Level.INFO,task+<span class="string">&quot;加入任务队列========&quot;</span>);</span><br><span class="line">            deque.addLast(task);</span><br><span class="line">            delCon.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带超时时间的添加任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(T task,Long time,TimeUnit unit)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(time);</span><br><span class="line">            <span class="keyword">while</span>(deque.size()==len)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    logger.log(Level.INFO,task+<span class="string">&quot;等待加入任务队列---------&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(nanos&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = addCon.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.log(Level.INFO,task+<span class="string">&quot;加入任务队列========&quot;</span>);</span><br><span class="line">            deque.addLast(task);</span><br><span class="line">            delCon.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列的容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> deque.size();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带拒绝策略的添加任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rejectPoilicy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPut</span><span class="params">(RejectPoilicy&lt;T&gt; rejectPoilicy, T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//判断队列是否已满</span></span><br><span class="line">            <span class="keyword">if</span>(deque.size()==len)&#123;</span><br><span class="line">                rejectPoilicy.reject(<span class="built_in">this</span>,task);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                logger.log(Level.INFO,task+<span class="string">&quot;加入任务队列========&quot;</span>);</span><br><span class="line">                deque.addLast(task);</span><br><span class="line">                delCon.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>​由于拒绝策略有好几种实现方案，这里我们使用定义一个拒绝策略的接口，让调用者使用函数式编程或Lambda表达式来自己实现其中的方法。定义的接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拒绝策略接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectPoilicy</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueueTest&lt;T&gt; queue,T task)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h4><p>​这里我没有单独写一个线程工厂，而是在线程池的里面定义了一个内部类，来执行提交的任务，同时在里面通过名字来核心线程与普通线程，这决定了他们在执行完任务后会不会结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原子类</span></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">threadNo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 工作线程类</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line">        <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Worker</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.task=task;</span><br><span class="line">            setThreadName();</span><br><span class="line">            <span class="built_in">this</span>.setName(threadName);</span><br><span class="line">            logger.log(Level.INFO,threadName+<span class="string">&quot;已创建..........&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreadName</span><span class="params">()</span>&#123;</span><br><span class="line">            threadName = <span class="string">&quot;simpleThread-&quot;</span> + threadNo.get();</span><br><span class="line">            threadNo.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> threadName.charAt(<span class="number">13</span>);</span><br><span class="line">            <span class="keyword">if</span>((c-<span class="string">&#x27;0&#x27;</span>)&lt;=coreSize)&#123;<span class="comment">//对比线程编号，小于核心线程数的线程调用阻塞执行任务，执行结束后不移出线程队列</span></span><br><span class="line">                gorun();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//大于核心线程数的采用限时等待执行，执行结束后移除出线程队列</span></span><br><span class="line">                go();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 普通线程执行完任务后限时等待任务队列，移除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(task != <span class="literal">null</span> || (task = blockingQueueTest.poll(outTime,unit)) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    logger.log(Level.INFO,<span class="string">&quot;普通线程&quot;</span>+threadName+<span class="string">&quot;正在执行&quot;</span>+task+<span class="string">&quot;任务....................&quot;</span>);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">                logger.log(Level.INFO,<span class="string">&quot;*******worker被移除&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">                workers.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 核心线程执行完任务后阻塞等待任务队列，不移除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">gorun</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(task != <span class="literal">null</span> || (task = blockingQueueTest.get()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    logger.log(Level.INFO,<span class="string">&quot;核心线程&quot;</span>+threadName+<span class="string">&quot;正在执行&quot;</span>+task+<span class="string">&quot;任务....................&quot;</span>);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="线程池类"><a href="#线程池类" class="headerlink" title="线程池类"></a>线程池类</h4><p>​关于线程池要使用的基本都已经编写完，接下来编写线程池类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义线程池类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line">    java.util.logging.Logger logger= getLogger(<span class="string">&quot;ThreadPool&quot;</span>);</span><br><span class="line">    <span class="comment">//阻塞任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueueTest&lt;Runnable&gt; blockingQueueTest;</span><br><span class="line">    <span class="comment">//线程集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> coreSize;</span><br><span class="line">    <span class="comment">//最大线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxThreadSize;</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> outTime;</span><br><span class="line">    <span class="comment">//时间单位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeUnit unit;</span><br><span class="line">    <span class="comment">//原子类</span></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">threadNo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//线程工厂</span></span><br><span class="line"><span class="comment">//    private final ThreadFactory threadFactory;</span></span><br><span class="line">    <span class="comment">//拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RejectPoilicy&lt;Runnable&gt; rejectPoilicy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> coreSize,<span class="type">int</span> maxThreadSize, <span class="type">long</span> outTime, TimeUnit unit, <span class="type">int</span> queueSize, RejectPoilicy&lt;Runnable&gt; rejectPoilicy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.maxThreadSize=maxThreadSize;</span><br><span class="line">        <span class="built_in">this</span>.outTime = outTime;</span><br><span class="line">        <span class="built_in">this</span>.unit = unit;</span><br><span class="line">        <span class="built_in">this</span>.blockingQueueTest = <span class="keyword">new</span> <span class="title class_">BlockingQueueTest</span>&lt;&gt;(queueSize);</span><br><span class="line"><span class="comment">//        this.threadFactory=threadFactory;</span></span><br><span class="line">        <span class="built_in">this</span>.rejectPoilicy = rejectPoilicy;</span><br><span class="line">        logger.log(Level.INFO,<span class="string">&quot;====================ThreadPool初始化成功=================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">            <span class="comment">//如果任务数没有超过核心线程数，直接交给worker执行</span></span><br><span class="line">            <span class="keyword">if</span>(workers.size()&lt;coreSize) &#123;</span><br><span class="line">                <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                logger.log(Level.INFO, <span class="string">&quot;=============================新增worker:&quot;</span> + worker);</span><br><span class="line">                logger.log(Level.INFO, <span class="string">&quot;=============新增task:&quot;</span> + task);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!blockingQueueTest.isTrue()) &#123;</span><br><span class="line">                <span class="comment">//如果线程数达到核心线程数，阻塞队列不满，则将任务加入任务队列</span></span><br><span class="line">                blockingQueueTest.put(task);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(workers.size()&lt;maxThreadSize)&#123;</span><br><span class="line">                <span class="comment">//如果阻塞队列已满，单线程数小于最大线程数，则立即创建线程执行该任务</span></span><br><span class="line">                <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                logger.log(Level.INFO, <span class="string">&quot;=============================新增worker:&quot;</span> + worker);</span><br><span class="line">                logger.log(Level.INFO, <span class="string">&quot;=============新增task:&quot;</span> + task);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//线程数大于最大线程数，为其执行拒绝策略</span></span><br><span class="line">                blockingQueueTest.tryPut(rejectPoilicy,task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作线程类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>接下来编写一个测试类来实验一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.logging.Logger.getLogger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        java.util.logging.Logger logger= getLogger(<span class="string">&quot;TestPool&quot;</span>);</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">2</span>,<span class="number">4</span>, <span class="number">1</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="number">3</span>, (queue,task)-&gt;&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.阻塞等待加入等待队列</span></span><br><span class="line"><span class="comment">             *      queue.put(task);</span></span><br><span class="line"><span class="comment">             *      一直等待加入队列</span></span><br><span class="line"><span class="comment">             * 2.带等待时间的等待加入</span></span><br><span class="line"><span class="comment">             *      queue.offer(task, 1500L, TimeUnit.MILLISECONDS);</span></span><br><span class="line"><span class="comment">             *      在预期时间内等待，超时则退出等待</span></span><br><span class="line"><span class="comment">             * 3.让调用者放弃任务执行</span></span><br><span class="line"><span class="comment">             *      logger.log(Level.INFO,&quot;^^^^^^^^^^^^放弃执行&quot;+task+&quot;了^^^^^^^&quot;);</span></span><br><span class="line"><span class="comment">             *      放弃无法加入等待队列的任务</span></span><br><span class="line"><span class="comment">             * 4.让调用者抛出异常</span></span><br><span class="line"><span class="comment">             *      throw new RuntimeException(&quot;任务执行失败&quot;+task);</span></span><br><span class="line"><span class="comment">             *      之后的代码不会执行</span></span><br><span class="line"><span class="comment">             * 5.让调用者自己执行任务</span></span><br><span class="line"><span class="comment">             *      task.run();</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            queue.put(task);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            pool.execute(()-&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                logger.log(Level.INFO, String.valueOf(j));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool <init><br>信息: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ThreadPool初始化成功&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool$Worker <init><br>信息: simpleThread-1已创建……….<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool execute<br>信息: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;新增worker:Thread[simpleThread-1,5,main]<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool execute<br>信息: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;新增task:suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@b4c966a<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool$Worker <init><br>信息: simpleThread-2已创建……….<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool$Worker gorun<br>信息: 核心线程simpleThread-1正在执行suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@b4c966a任务………………..<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool execute<br>信息: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;新增worker:Thread[simpleThread-2,5,main]<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool execute<br>信息: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;新增task:suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@4e50df2e<br>五月 20, 2023 10:00:22 下午 suan.JUC.BlockingQueueTest put<br>信息: suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@1d81eb93加入任务队列&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool$Worker gorun<br>信息: 核心线程simpleThread-2正在执行suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@4e50df2e任务………………..<br>五月 20, 2023 10:00:22 下午 suan.JUC.BlockingQueueTest put<br>信息: suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@7291c18f加入任务队列&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>五月 20, 2023 10:00:22 下午 suan.JUC.BlockingQueueTest put<br>信息: suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@34a245ab加入任务队列&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool$Worker <init><br>信息: simpleThread-3已创建……….<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool execute<br>信息: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;新增worker:Thread[simpleThread-3,5,main]<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool execute<br>信息: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;新增task:suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@6e8cf4c6<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool$Worker <init><br>信息: simpleThread-4已创建……….<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool$Worker go<br>信息: 普通线程simpleThread-3正在执行suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@6e8cf4c6任务………………..<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool execute<br>信息: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;新增worker:Thread[simpleThread-4,5,main]<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool execute<br>信息: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;新增task:suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@34c45dca<br>五月 20, 2023 10:00:22 下午 suan.JUC.BlockingQueueTest put<br>信息: suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@52cc8049等待加入任务队列———<br>五月 20, 2023 10:00:22 下午 suan.JUC.ThreadPool$Worker go<br>信息: 普通线程simpleThread-4正在执行suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@34c45dca任务………………..<br>五月 20, 2023 10:00:23 下午 suan.JUC.TestPool lambda$main$1<br>信息: 5<br>五月 20, 2023 10:00:23 下午 suan.JUC.TestPool lambda$main$1<br>信息: 0<br>五月 20, 2023 10:00:23 下午 suan.JUC.TestPool lambda$main$1<br>信息: 6<br>五月 20, 2023 10:00:23 下午 suan.JUC.TestPool lambda$main$1<br>信息: 1<br>五月 20, 2023 10:00:23 下午 suan.JUC.BlockingQueueTest put<br>信息: suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@52cc8049加入任务队列&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>五月 20, 2023 10:00:23 下午 suan.JUC.ThreadPool$Worker go<br>信息: 普通线程simpleThread-3正在执行suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@1d81eb93任务………………..<br>五月 20, 2023 10:00:23 下午 suan.JUC.BlockingQueueTest put<br>信息: suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@27973e9b等待加入任务队列———<br>五月 20, 2023 10:00:23 下午 suan.JUC.ThreadPool$Worker gorun<br>信息: 核心线程simpleThread-1正在执行suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@7291c18f任务………………..<br>五月 20, 2023 10:00:23 下午 suan.JUC.BlockingQueueTest put<br>信息: suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@27973e9b加入任务队列&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>五月 20, 2023 10:00:23 下午 suan.JUC.ThreadPool$Worker gorun<br>信息: 核心线程simpleThread-2正在执行suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@52cc8049任务………………..<br>五月 20, 2023 10:00:23 下午 suan.JUC.ThreadPool$Worker go<br>信息: 普通线程simpleThread-4正在执行suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@34a245ab任务………………..<br>五月 20, 2023 10:00:23 下午 suan.JUC.BlockingQueueTest put<br>信息: suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@312b1dae加入任务队列&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>五月 20, 2023 10:00:24 下午 suan.JUC.TestPool lambda$main$1<br>信息: 2<br>五月 20, 2023 10:00:24 下午 suan.JUC.ThreadPool$Worker go<br>信息: 普通线程simpleThread-3正在执行suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@27973e9b任务………………..<br>五月 20, 2023 10:00:24 下午 suan.JUC.TestPool lambda$main$1<br>信息: 3<br>五月 20, 2023 10:00:24 下午 suan.JUC.TestPool lambda$main$1<br>信息: 4<br>五月 20, 2023 10:00:24 下午 suan.JUC.TestPool lambda$main$1<br>信息: 7<br>五月 20, 2023 10:00:24 下午 suan.JUC.ThreadPool$Worker gorun<br>信息: 核心线程simpleThread-1正在执行suan.JUC.TestPool$$Lambda$2&#x2F;1072408673@312b1dae任务………………..<br>五月 20, 2023 10:00:25 下午 suan.JUC.TestPool lambda$main$1<br>信息: 8<br>五月 20, 2023 10:00:25 下午 suan.JUC.TestPool lambda$main$1<br>信息: 9<br>五月 20, 2023 10:00:25 下午 suan.JUC.ThreadPool$Worker go<br>信息: *******worker被移除Thread[simpleThread-4,5,main]<br>五月 20, 2023 10:00:26 下午 suan.JUC.ThreadPool$Worker go<br>信息: *******worker被移除Thread[simpleThread-3,5,main]</p></blockquote><p>成功，且由于核心线程并没有结束，所以我们的进程并没有结束。</p><p>以上就是手写一个线程类的思路代码，另外这只是一个简单的实现，很多功能向关闭线程池的功能就没有编写，仅仅作为加深线程池的理解的一种方式，如有错误或可改进的地方，欢迎指正！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;JUC之手写一个简单的线程池&quot;&gt;&lt;a href=&quot;#JUC之手写一个简单的线程池&quot; class=&quot;headerlink&quot; title=&quot;JUC之手写一个简单的线程池&quot;&gt;&lt;/a&gt;JUC之手写一个简单的线程池&lt;/h3&gt;&lt;p&gt;​		在之前介绍了</summary>
      
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC之线程池的标准创建方式</title>
    <link href="http://example.com/2023/05/20/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%87%E5%87%86%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2023/05/20/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%87%E5%87%86%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</id>
    <published>2023-05-20T03:24:56.000Z</published>
    <updated>2023-07-23T09:15:23.003Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="JUC之线程池的标准创建方式"><a href="#JUC之线程池的标准创建方式" class="headerlink" title="JUC之线程池的标准创建方式"></a>JUC之线程池的标准创建方式</h3><p>​因为使用Executors快捷创建线程池在使用时会有严重的潜在问题，因此在实战使用时一般不使用快捷创建线程池的方式在创建线程池，而是使用ThreadPoolExecutor的标准构造器去构建线程池。Executors工厂类中创建线程池的快捷工厂方法实际上是调用 ThreadPoolExecutor（定时任务使用ScheduledThreadPoolExecutor） 线程池的构造方法完成的。</p><p>​ThreadPoolExecutor构造方法有多个重载版本，较重要的一个构造器包含七个参数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//核心线程数，即使线程空闲也不会回收</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,//最大线程数</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,//线程的最大空闲时长</span></span><br><span class="line"><span class="params">                              TimeUnit unit,//时长单位</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//任务队列</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,//线程工厂，新线程的创建方式</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> <span class="comment">//拒绝策略</span></span><br></pre></td></tr></table></figure><h4 id="核心和最大线程数量"><a href="#核心和最大线程数量" class="headerlink" title="核心和最大线程数量"></a>核心和最大线程数量</h4><p>​参数corePoolSize用于设置核心（Core）线程池数量，参数 maximumPoolSize用于设置最大线程数量。线程池执行器将会根据 corePoolSize和maximumPoolSize自动维护线程池中的工作线程，大致 规则为：</p><ol><li>当在线程池接收到新任务，并且当前工作线程数少于 corePoolSize时，即使其他工作线程处于空闲状态，也会创建一个新 线程来处理该请求，直到线程数达到corePoolSize。</li><li>如果当前工作线程数多于corePoolSize数量，但小于 maximumPoolSize数量，那么仅当任务排队队列已满时才会创建新线 程。通过设置corePoolSize和maximumPoolSize相同，可以创建一个固 定大小的线程池。</li><li>当maximumPoolSize被设置为无界值（如 Integer.MAX_VALUE）时，线程池可以接收任意数量的并发任务。</li><li>corePoolSize和maximumPoolSize不仅能在线程池构造时设 置，也可以调用setCorePoolSize()和setMaximumPoolSize()两个方法 进行动态更改。</li></ol><h4 id="空闲时长-keepAliveTime"><a href="#空闲时长-keepAliveTime" class="headerlink" title="空闲时长(keepAliveTime)"></a>空闲时长(keepAliveTime)</h4><p>​线程构造器的keepAliveTime（空闲线程存活时间）参数用于设置 池内线程最大Idle（空闲）时长（或者说保活时长），如果超过这个 时间，默认情况下Idle、非Core线程会被回收。</p><p>​如果池在使用过程中提交任务的频率变高，也可以调用方法 setKeepAliveTime(long，TimeUnit)进行线程存活时间的动态调整， 可以将时长延长。如果需要防止Idle线程被终止，可以将Idle时间设 置为无限大，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setKeepAliveTime(Long.MAX_VALUE，TimeUnit.NANOSECONDS);</span><br></pre></td></tr></table></figure><p>​默认情况下，Idle超时策略仅适用于存在超过corePoolSize线程 的情况。但若调用了allowCoreThreadTimeOut(boolean)方法，并且传 入了参数true，则keepAliveTime参数所设置的Idle超时策略也将被应 用于核心线程。</p><h4 id="线程工厂-ThreadFactory"><a href="#线程工厂-ThreadFactory" class="headerlink" title="线程工厂(ThreadFactory)"></a>线程工厂(ThreadFactory)</h4><p>​ThreadFactory是Java线程工厂接口，这是一个非常简单的接口， 具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span>;<span class="comment">//唯一的方法：创建一个新线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在调用ThreadFactory的唯一方法newThread()创建新线程时，可 以更改所创建的新线程的名称、线程组、优先级、守护进程状态等。 如果newThread()的返回值为null，表示线程工厂未能成功创建线程， 线程池可能无法执行任何任务。</p><p>​使用Executors创建新的线程池时，也可以基于 ThreadFactory（线程工厂）创建，在创建新线程池时可以指定将要使 用的ThreadFactory实例。只不过，如果没有指定的话，就会使用 Executors.defaultThreadFactory默认实例。使用默认的线程工厂实 例所创建的线程全部位于同一个ThreadGroup（线程组）中，具有相同 的NORM_PRIORITY（优先级为5），而且都是非守护进程状态。</p><p>自定义一个线程工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">threadNo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> <span class="string">&quot;simpleThread-&quot;</span> + threadNo.get();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;创建一个线程，名称为：&quot;</span>+threadName);</span><br><span class="line">            threadNo.incrementAndGet();</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,threadName);</span><br><span class="line">            thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任务阻塞队列"><a href="#任务阻塞队列" class="headerlink" title="任务阻塞队列"></a>任务阻塞队列</h4><p>​Java中的阻塞队列（BlockingQueue）与普通队列相比有一个重要 的特点：在阻塞队列为空时会阻塞当前线程的元素获取操作。具体来 说，在一个线程从一个空的阻塞队列中获取元素时线程会被阻塞，直 到阻塞队列中有了元素；当队列中有元素后，被阻塞的线程会自动被 唤醒（唤醒过程不需要用户程序干预）。</p><p>​Java线程池使用BlockingQueue实例暂时接收到的异步任务， BlockingQueue是JUC包的一个超级接口，比较常用的实现类有：</p><ol><li><p>ArrayBlockingQueue：是一个数组实现的有界阻塞队列（有 界队列），队列中的元素按FIFO排序。ArrayBlockingQueue在创建时 必须设置大小，接收的任务超出corePoolSize数量时，任务被缓存到 该阻塞队列中，任务缓存的数量只能为创建时设置的大小，若该阻塞 队列已满，则会为新的任务创建线程，直到线程池中的线程总数大于 maximumPoolSize。</p></li><li><p>LinkedBlockingQueue：是一个基于链表实现的阻塞队列， 按FIFO排序任务，可以设置容量（有界队列），不设置容量则默认使 用Integer.Max_VALUE作为容量（无界队列）。该队列的吞吐量高于 ArrayBlockingQueue。</p><p>​如果不设置LinkedBlockingQueue的容量（无界队列），当接收的 任务数量超出corePoolSize时，则新任务可以被无限制地缓存到该阻 塞队列中，直到资源耗尽。有两个快捷创建线程池的工厂方法 Executors.newSingleThreadExecutor和 Executors.newFixedThreadPool使用了这个队列，并且都没有设置容 量（无界队列）。</p></li><li><p>PriorityBlockingQueue：是具有优先级的无界队列。</p></li><li><p>DelayQueue：这是一个无界阻塞延迟队列，底层基于 PriorityBlockingQueue实现，队列中每个元素都有过期时间，当从队 列获取元素（元素出队）时，只有已经过期的元素才会出队，队列头 部的元素是过期最快的元素。快捷工厂方法 Executors.newScheduledThreadPool所创建的线程池使用此队列。</p></li><li><p>SynchronousQueue：（同步队列）是一个不存储元素的阻塞 队列，每个插入操作必须等到另一个线程的调用移除操作，否则插入 操作一直处于阻塞状态，其吞吐量通常高于LinkedBlockingQueue。快 捷工厂方法Executors.newCachedThreadPool所创建的线程池使用此队 列。与前面的队列相比，这个队列比较特殊，它不会保存提交的任 务，而是直接新建一个线程来执行新来的任务。</p></li></ol><h4 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h4><p>​在线程池的任务缓存队列为有界队列（有容量限制的队列）的时 候，如果队列满了，提交任务到线程池的时候就会被拒绝。总体来 说，任务被拒绝有两种情况：</p><ol><li>线程池已经被关闭。</li><li>工作队列已满且maximumPoolSize已满。</li></ol><p>​无论以上哪种情况任务被拒绝，线程池都会调用 RejectedExecutionHandler实例的rejectedExecution方法。 RejectedExecutionHandler是拒绝策略的接口，JUC为该接口提供了以 下几种实现：</p><ul><li><p>AbortPolicy：拒绝策略。使用该策略时，如果线程池队列满了，新任务就会被拒绝，并且 抛出RejectedExecutionException异常。该策略是线程池默认的拒绝 策略。</p></li><li><p>DiscardPolicy：抛弃策略。该策略是AbortPolicy的Silent（安静）版本，如果线程池队列满 了，新任务就会直接被丢掉，并且不会有任何异常抛出。</p></li><li><p>DiscardOldestPolicy：抛弃最老任务策略。也就是说如果队列满了，就会将最早进入队 列的任务抛弃，从队列中腾出空间，再尝试加入队列。因为队列是队 尾进队头出，队头元素是最老的，所以每次都是移除队头元素后再尝 试入队。</p></li><li><p>CallerRunsPolicy：调用者执行策略。在新任务被添加到线程池时，如果添加失败， 那么提交任务线程会自己去执行该任务，不会使用线程池中的线程去 执行新任务。</p></li><li><p>自定义策略。如果以上拒绝策略都不符合需求，那么可自定义一个拒绝策略， 实现RejectedExecutionHandler接口的rejectedExecution方法即可。</p></li></ul><h4 id="线程池的任务调度流程"><a href="#线程池的任务调度流程" class="headerlink" title="线程池的任务调度流程"></a>线程池的任务调度流程</h4><p>​线程池的任务调度流程（包含接收新任务和执行下一个任务）大 致如下：</p><ol><li>如果当前工作线程数量小于核心线程数量，执行器总是优先 创建一个任务线程，而不是从线程队列中获取一个空闲线程。</li><li>如果线程池中总的任务数量大于核心线程池数量，新接收的 任务将被加入阻塞队列中，一直到阻塞队列已满。在核心线程池数量 已经用完、阻塞队列没有满的场景下，线程池不会为新任务创建一个 新线程。</li><li>当完成一个任务的执行时，执行器总是优先从阻塞队列中获 取下一个任务，并开始执行，一直到阻塞队列为空，其中所有的缓存 任务被取光。</li><li>在核心线程池数量已经用完、阻塞队列也已经满了的场景 下，如果线程池接收到新的任务，将会为新任务创建一个线程（非核 心线程），并且立即开始执行新任务。</li><li>在核心线程都用完、阻塞队列已满的情况下，一直会创建新 线程去执行新任务，直到池内的线程总数超出maximumPoolSize。如果 线程池的线程总数超过maximumPoolSize，线程池就会拒绝接收任务， 当新任务过来时，会为新任务执行拒绝策略。</li></ol><p>总体的线程池调度流程如图：</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/c9fbabf8b52a8150.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;JUC之线程池的标准创建方式&quot;&gt;&lt;a href=&quot;#JUC之线程池的标准创建方式&quot; class=&quot;headerlink&quot; title=&quot;JUC之线程池的标准创建方式&quot;&gt;&lt;/a&gt;JUC之线程池的标准创建方式&lt;/h3&gt;&lt;p&gt;​		因为使用Ex</summary>
      
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch之基本API操作</title>
    <link href="http://example.com/2023/04/24/Elasticsearch/"/>
    <id>http://example.com/2023/04/24/Elasticsearch/</id>
    <published>2023-04-24T03:24:56.000Z</published>
    <updated>2023-07-23T09:08:51.287Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Elasticsearch之基本API操作"><a href="#Elasticsearch之基本API操作" class="headerlink" title="Elasticsearch之基本API操作"></a>Elasticsearch之基本API操作</h5><h6 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h6><p>创建索引：使用PUT请求，<a href="http://localhost:9200/">http://localhost:9200/</a> + 索引名称</p><p>创建索引的映射:PUT, <a href="http://localhost:9200/+%E7%B4%A2%E5%BC%95%E5%90%8D%E7%A7%B0+/_mapping">http://localhost:9200/+索引名称+/_mapping</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="string">&quot;index&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;sex&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="string">&quot;index&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;tel&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="string">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mapping映射属性</span></span><br><span class="line">type：字段数据类型，常见的简单类型有：</span><br><span class="line">    字符串：text（可分词的文本）、keyword（精确值，如：品牌、国家、IP地址）</span><br><span class="line">    数值：<span class="type">long</span>、integer、<span class="type">short</span>、<span class="type">byte</span>、<span class="type">double</span>、<span class="type">float</span></span><br><span class="line">    布尔：<span class="type">boolean</span></span><br><span class="line">    日期：date</span><br><span class="line">    对象：object</span><br><span class="line">index：是否创建索引，默认是<span class="literal">true</span></span><br><span class="line">analyzer：分词器，使用何种分词器</span><br><span class="line">properties：该字段的子字段</span><br><span class="line">ES中支持的两种地理坐标数据类型：</span><br><span class="line">    geo_point:由维度(latitude)和经度(longitude)确定的一个点。如：<span class="string">&quot;32.8752345,120.2981576&quot;</span></span><br><span class="line">    geo_shape:由多个geo_point组成的复杂几何图形。如一条直线。</span><br></pre></td></tr></table></figure><p>查询映射：GET, <a href="http://localhost:9200/+%E7%B4%A2%E5%BC%95%E5%90%8D%E7%A7%B0+/_mapping">http://localhost:9200/+索引名称+/_mapping</a></p><p>删除索引：使用DELETE请求，<a href="http://localhost:9200/">http://localhost:9200/</a> + 索引名称</p><p>获取索引：使用GET请求，<a href="http://localhost:9200/">http://localhost:9200/</a> + 索引名称</p><p>获取所有索引：使用GET请求，<a href="http://localhost:9200/_cat/indices?v">http://localhost:9200/_cat/indices?v</a></p><p><strong>索引映射创建后不允许修改，但允许添加新字段的索引映射</strong></p><h6 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h6><p>上传数据：使用POST请求，<a href="http://localhost:9200/">http://localhost:9200/</a> + 索引名称 + &#x2F;_doc （+&#x2F;3 指定数据的id，不加则使用默认生成的id），此处需要注意：<strong>如果增加数据时明确数据主键，那么请求方式也可以为 PUT</strong> </p><p>删除数据：使用delete请求，<a href="http://localhost:9200/+">http://localhost:9200/+</a> 索引名称 +&#x2F;_doc&#x2F;+ 数据的id</p><p>获取单条数据：使用GET请求，<a href="http://localhost:9200/+">http://localhost:9200/+</a> 索引名称 +&#x2F;_doc&#x2F;+ 数据的id</p><p>获取索引下的所有数据：使用GET请求，<a href="http://localhost:9200/+">http://localhost:9200/+</a> 索引名称 +&#x2F;_search</p><p>修改数据：若要修改所有数据，跟上传数据一样，会自动覆盖之前的数据；若只修改部分数据，使用POST请求，<a href="http://localhost:9200/">http://localhost:9200/</a> + 索引名称 + &#x2F;_update&#x2F;+ id   文件格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;doc&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;键名&quot;</span>:<span class="string">&quot;值&quot;</span>,</span><br><span class="line"><span class="string">&quot;键名&quot;</span>:<span class="string">&quot;值&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带参查询：URL带参，GET请求，<a href="http://localhost:9200/+%E7%B4%A2%E5%BC%95%E5%90%8D%E7%A7%B0+/_search/q=%E9%94%AE%E5%90%8D%EF%BC%9A%E5%80%BC">http://localhost:9200/+索引名称+/_search/q=键名：值</a></p><p>请求体带参，GET请求，<a href="http://localhost:9200/+%E7%B4%A2%E5%BC%95%E5%90%8D%E7%A7%B0+/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E8%AF%B7%E6%B1%82%E4%BD%93%EF%BC%9A">http://localhost:9200/+索引名称+/_search，附带JSON请求体：</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">查找符合条件的数据：</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span>:<span class="string">&quot;一测&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">全查：</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;match_all&quot;</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">查询指定字段：</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;match_all&quot;</span>:&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;_source&quot;</span>:[<span class="string">&quot;键名&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">分页查询：</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;match_all&quot;</span>:&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;from&quot;</span>:<span class="number">0</span>,</span><br><span class="line"><span class="string">&quot;size&quot;</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">排序查询：</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;match_all&quot;</span>:&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;sort&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;键名&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;order&quot;</span>:<span class="string">&quot;desc&quot;</span><span class="comment">//降序(asc升序)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">多条件查询：</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;bool&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;must&quot;</span>:[&#123;</span><br><span class="line"><span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span>:<span class="string">&quot;一&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line"><span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>:<span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">范围查询：</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;bool&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;should&quot;</span>:[&#123;</span><br><span class="line"><span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;content&quot;</span>:<span class="string">&quot;它&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line"><span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span>:<span class="string">&quot;一&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;],</span><br><span class="line">            <span class="string">&quot;filter&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;range&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;gt&quot;</span>:<span class="number">20</span><span class="comment">//大于</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">完全匹配：</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;match_phrase&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span> : <span class="string">&quot;一&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">高亮查询：</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;match_phrase&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span> : <span class="string">&quot;一&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="string">&quot;highlight&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;fields&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;title&quot;</span>:&#123;&#125;<span class="comment">//&lt;----高亮这字段</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">聚合查询：</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;aggs&quot;</span>:&#123;<span class="comment">//聚合操作</span></span><br><span class="line"><span class="string">&quot;price_group&quot;</span>:&#123;<span class="comment">//名称，随意起名</span></span><br><span class="line"><span class="string">&quot;terms&quot;</span>:&#123;<span class="comment">//分组</span></span><br><span class="line"><span class="string">&quot;field&quot;</span>:<span class="string">&quot;price&quot;</span><span class="comment">//分组字段</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;，</span><br><span class="line">        <span class="string">&quot;size&quot;</span>:<span class="number">0</span><span class="comment">//不附带原始结果</span></span><br><span class="line">&#125;</span><br><span class="line">对某一字段求平均值：</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;price_avg&quot;</span>:&#123;<span class="comment">//名称，随意起名</span></span><br><span class="line"><span class="string">&quot;avg&quot;</span>:&#123;<span class="comment">//求平均</span></span><br><span class="line"><span class="string">&quot;field&quot;</span>:<span class="string">&quot;price&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="string">&quot;size&quot;</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>elasticsearch中的相关性打分算法</p><ul><li>TF-IDF：在elasticsearch5.0之前使用，会随着词频增加而越来越大</li><li>BM25：在elasticsearch5.0之后使用，会随着词频增加而增大，但增长曲线会趋于水平</li></ul><p><strong>Function Score Query</strong></p><p>使用Function Score Query可以修改文档的相关性算分（query score），根据新得到的算分排序。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/75481f85449581ad.png"></p><p>Function Score Query定义的三要素是什么？</p><ul><li>过滤条件：哪些文档要加分</li><li>算分函数：如何计算function score</li><li>加权方式：function score与query score如何运算</li></ul><p><strong>复合查询Boolean Query</strong></p><p>布尔查询是一个或多个查询子句的组合，子查询的组合方式有：</p><ul><li>must：必须匹配每个子查询，类似   与</li><li>should：选择性匹配子查询，类似   或</li><li>must_not：必须不匹配，不参与算分，类似   非</li><li>filter：必须匹配，不参与算分</li></ul><p>自定义分词器</p><p>elasticsearch中分词器（analyzer）的组成包含三部分：</p><ul><li>character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li><li>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart</li><li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</li></ul><p><strong>为了避免搜索时搜到同音字，应在创建索引时使用拼音分词器，但搜索时不应使用拼音分词器。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;Elasticsearch之基本API操作&quot;&gt;&lt;a href=&quot;#Elasticsearch之基本API操作&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch之基本API操作&quot;&gt;&lt;/a&gt;Elasticsearch之基本API操作&lt;/</summary>
      
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Elasticsearch" scheme="http://example.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>JUC之Executors的4种快捷创建线程池的方法</title>
    <link href="http://example.com/2023/04/20/JUC%E4%B9%8BExecutors%E7%9A%844%E7%A7%8D%E5%BF%AB%E6%8D%B7%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2023/04/20/JUC%E4%B9%8BExecutors%E7%9A%844%E7%A7%8D%E5%BF%AB%E6%8D%B7%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2023-04-20T03:24:56.000Z</published>
    <updated>2023-07-23T08:32:30.193Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="JUC之Executors的4种快捷创建线程池的方法"><a href="#JUC之Executors的4种快捷创建线程池的方法" class="headerlink" title="JUC之Executors的4种快捷创建线程池的方法"></a>JUC之Executors的4种快捷创建线程池的方法</h2><p>Java通过Executors工厂类提供了4种快捷创建线程池的方法，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newSingleThreadExecutor()<span class="comment">//创建只有一个线程的线程池</span></span><br><span class="line">newFixedThreadPool(<span class="type">int</span> nThreads)<span class="comment">//创建固定大小的线程池</span></span><br><span class="line">newCachedThreadPool()<span class="comment">//创建一个不限制线程数量的线程池，任何提交的任务都将立即执行，但是空闲线程会得到及时回收</span></span><br><span class="line">newScheduledThreadPool()<span class="comment">//创建一个可定期或者延时执行任务的线程池</span></span><br></pre></td></tr></table></figure><h4 id="newSingleThreadExecutor创建“单线程化线程池”"><a href="#newSingleThreadExecutor创建“单线程化线程池”" class="headerlink" title="newSingleThreadExecutor创建“单线程化线程池”"></a>newSingleThreadExecutor创建“单线程化线程池”</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadPoolDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SLEEP_GAP</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TargetTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">taskNo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> String taskName;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TargetTask</span><span class="params">()</span>&#123;</span><br><span class="line">            taskName = <span class="string">&quot;task-&quot;</span> + taskNo.get();</span><br><span class="line">            taskNo.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;任务：&quot;</span>+taskName+<span class="string">&quot;doing&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(SLEEP_GAP);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;运行结束。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">TargetTask</span>());</span><br><span class="line">            pool.submit(<span class="keyword">new</span> <span class="title class_">TargetTask</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>pool-1-thread-1任务：task-1doing<br>pool-1-thread-1运行结束。<br>pool-1-thread-1任务：task-2doing<br>pool-1-thread-1运行结束。<br>pool-1-thread-1任务：task-3doing<br>pool-1-thread-1运行结束。<br>pool-1-thread-1任务：task-4doing<br>pool-1-thread-1运行结束。<br>pool-1-thread-1任务：task-5doing<br>pool-1-thread-1运行结束。<br>pool-1-thread-1任务：task-6doing<br>pool-1-thread-1运行结束。</p></blockquote><ol><li>单线程化的线程池中的任务是按照提交的次序顺序执行的。</li><li>池中的唯一线程的存活时间是无限的。</li><li>当池中的唯一线程正繁忙时，新提交的任务实例会进入内部 的阻塞队列中，并且其阻塞队列是无界的。</li><li>适用于任务按照提交次序，一个任务一个任务饿逐个执行的场景。</li></ol><h4 id="newFixedThreadPool创建“固定数量的线程池”"><a href="#newFixedThreadPool创建“固定数量的线程池”" class="headerlink" title="newFixedThreadPool创建“固定数量的线程池”"></a>newFixedThreadPool创建“固定数量的线程池”</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadPoolDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">TargetTask</span>());</span><br><span class="line">            pool.submit(<span class="keyword">new</span> <span class="title class_">TargetTask</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SLEEP_GAP</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TargetTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">taskNo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> String taskName;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TargetTask</span><span class="params">()</span>&#123;</span><br><span class="line">            taskName = <span class="string">&quot;task-&quot;</span> + taskNo.get();</span><br><span class="line">            taskNo.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;任务：&quot;</span>+taskName+<span class="string">&quot;doing&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(SLEEP_GAP);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;运行结束。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>pool-1-thread-1任务：task-1doing<br>pool-1-thread-2任务：task-2doing<br>pool-1-thread-3任务：task-3doing<br>pool-1-thread-1运行结束。<br>pool-1-thread-3运行结束。<br>pool-1-thread-2运行结束。<br>pool-1-thread-1任务：task-4doing<br>pool-1-thread-2任务：task-5doing<br>pool-1-thread-3任务：task-6doing<br>pool-1-thread-3运行结束。<br>pool-1-thread-1运行结束。<br>pool-1-thread-2运行结束。<br>pool-1-thread-1任务：task-8doing<br>pool-1-thread-3任务：task-7doing<br>pool-1-thread-2任务：task-9doing<br>pool-1-thread-2运行结束。<br>pool-1-thread-1运行结束。<br>pool-1-thread-3运行结束。<br>pool-1-thread-2任务：task-10doing<br>pool-1-thread-2运行结束。</p></blockquote><ol><li>如果线程数没有达到“固定数量”，每次提交一个任务线程池内就创建一个新线程，直到线程达到线程池固定的数量。</li><li>线程池的大小一旦达到“固定数量”就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li><li>在接收异步任务的执行目标实例时，如果池中的所有线程均在繁忙状态，新任务会进入阻塞队列中（无界的阻塞队列）。</li><li>适用于需要任务长期执行的场景。</li><li>弊端：内部使用无界队列来存放排队任务，当大量任务超过线程池最大容量需要处理时，队列无限增大，使服务器资源迅速耗尽。</li></ol><h4 id="newCachedThreadPool创建“可缓存线程池”"><a href="#newCachedThreadPool创建“可缓存线程池”" class="headerlink" title="newCachedThreadPool创建“可缓存线程池”"></a>newCachedThreadPool创建“可缓存线程池”</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadPoolDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">TargetTask</span>());</span><br><span class="line">            pool.submit(<span class="keyword">new</span> <span class="title class_">TargetTask</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SLEEP_GAP</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TargetTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">taskNo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> String taskName;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TargetTask</span><span class="params">()</span>&#123;</span><br><span class="line">            taskName = <span class="string">&quot;task-&quot;</span> + taskNo.get();</span><br><span class="line">            taskNo.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;任务：&quot;</span>+taskName+<span class="string">&quot;doing&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(SLEEP_GAP);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;运行结束。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>pool-1-thread-1任务：task-1doing<br>pool-1-thread-2任务：task-2doing<br>pool-1-thread-3任务：task-3doing<br>pool-1-thread-4任务：task-4doing<br>pool-1-thread-5任务：task-5doing<br>pool-1-thread-6任务：task-6doing<br>pool-1-thread-7任务：task-7doing<br>pool-1-thread-8任务：task-8doing<br>pool-1-thread-9任务：task-9doing<br>pool-1-thread-10任务：task-10doing<br>pool-1-thread-9运行结束。<br>pool-1-thread-8运行结束。<br>pool-1-thread-4运行结束。<br>pool-1-thread-1运行结束。<br>pool-1-thread-7运行结束。<br>pool-1-thread-5运行结束。<br>pool-1-thread-10运行结束。<br>pool-1-thread-2运行结束。<br>pool-1-thread-3运行结束。<br>pool-1-thread-6运行结束。</p></blockquote><ol><li>在接收新的异步任务target执行目标实例时，如果池内所有线程繁忙，此线程池就会添加新线程来处理任务。</li><li>此线程池不会对线程池大小进行限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li><li>如果部分线程空闲，也就是存量线程的数量超过了处理任务数量，就会回收空闲（60秒不执行任务）线程。</li><li>适用场景：需要快速处理突发性强、耗时较短的任务场景，如Netty的NIO处理场景、REST API接口的瞬时削峰场景。</li><li>弊端：没有最大线程数量限制，如果大量的异步任务执行目标实例同时提交，可能回因为创建过多线程而导致资源耗尽。</li></ol><h4 id="newScheduledThreadPool创建“可调度线程池”"><a href="#newScheduledThreadPool创建“可调度线程池”" class="headerlink" title="newScheduledThreadPool创建“可调度线程池”"></a>newScheduledThreadPool创建“可调度线程池”</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadPoolDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            service.scheduleAtFixedRate</span><br><span class="line">                    (<span class="keyword">new</span> <span class="title class_">CreateThreadPoolDemo1</span>.TargetTask(),<span class="number">0</span>,<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="comment">//            service.scheduleWithFixedDelay</span></span><br><span class="line"><span class="comment">//                    (new CreateThreadPoolDemo1.TargetTask(),0,1000,TimeUnit.MILLISECONDS);</span></span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SLEEP_GAP</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TargetTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">taskNo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> String taskName;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TargetTask</span><span class="params">()</span>&#123;</span><br><span class="line">            taskName = <span class="string">&quot;task-&quot;</span> + taskNo.get();</span><br><span class="line">            taskNo.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;任务：&quot;</span>+taskName+<span class="string">&quot;doing&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(SLEEP_GAP);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;运行结束。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​newScheduledThreadPool工厂方法可以创建一个执行“延时”和 “周期性”任务的可调度线程池，所创建的线程池为 ScheduleExecutorService类型的实例。ScheduleExecutorService接 口中有多个重要的接收被调目标任务的方法，其中 scheduleAtFixedRate和scheduleWithFixedDelay使用得比较多。</p><p>scheduleAtFixedRate:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(</span><br><span class="line">Runnable command, <span class="comment">//异步任务target执行目标实例</span></span><br><span class="line">    <span class="type">long</span> initialDelay, <span class="comment">//首次执行延时</span></span><br><span class="line"><span class="type">long</span> period, <span class="comment">//两次开始执行最小间隔时间</span></span><br><span class="line">    TimeUnit unit <span class="comment">//所设置的时间的计时单位，如TimeUnit.SECONDS常量</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>scheduleWithFixedDelay:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(</span><br><span class="line">    Runnable command, <span class="comment">//异步任务target执行目标实例</span></span><br><span class="line">    <span class="type">long</span> initialDelay, <span class="comment">//首次执行延时</span></span><br><span class="line">    <span class="type">long</span> delay, <span class="comment">//前一次执行结束到下一次执行开始的间隔时间（间隔执行延迟时间）</span></span><br><span class="line">    TimeUnit unit <span class="comment">//所设置的时间的计时单位，如TimeUnit.SECONDS常量</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>当被调任务的执行时间大于指定的间隔时间时， ScheduleExecutorService并不会创建一个新的线程去并发执行这个任 务，而是等待前一次调度执行完毕。</li><li>适用场景：周期性地执行任务的场景。</li></ol><h4 id="Executors快捷创建线程池的潜在问题"><a href="#Executors快捷创建线程池的潜在问题" class="headerlink" title="Executors快捷创建线程池的潜在问题"></a>Executors快捷创建线程池的潜在问题</h4><h5 id="FixedThreadPool和SingleThreadPool"><a href="#FixedThreadPool和SingleThreadPool" class="headerlink" title="FixedThreadPool和SingleThreadPool"></a>FixedThreadPool和SingleThreadPool</h5><p>​这两个工厂方法所创建的线程池，工作队列（任务排队的队列）的长度都为Integer.MAX_VALUE，可能会堆积大量的任务，从而导致OOM（即耗尽内存资源）。</p><h5 id="CachedThreadPool和ScheduledThreadPool"><a href="#CachedThreadPool和ScheduledThreadPool" class="headerlink" title="CachedThreadPool和ScheduledThreadPool"></a>CachedThreadPool和ScheduledThreadPool</h5><p>​这两个工厂方法所创建的线程池允许创建的线程数量为Integer.MAX_VALUE，可能会导致创建大量的线程，从而导致OOM。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;JUC之Executors的4种快捷创建线程池的方法&quot;&gt;&lt;a href=&quot;#JUC之Executors的4种快捷创建线程池的方法&quot; class=&quot;headerlink&quot; title=&quot;JUC之Executors的4种快捷创建线程池的方法&quot;</summary>
      
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC线程池之线程池架构</title>
    <link href="http://example.com/2023/04/13/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%B6%E6%9E%84/"/>
    <id>http://example.com/2023/04/13/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%B6%E6%9E%84/</id>
    <published>2023-04-13T03:24:56.000Z</published>
    <updated>2023-07-23T09:12:20.607Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JUC线程池之线程池架构"><a href="#JUC线程池之线程池架构" class="headerlink" title="JUC线程池之线程池架构"></a>JUC线程池之线程池架构</h3><p>在多线程编程中，任务都是一些抽象且离散的工作单元，而线程 是使任务异步执行的基本机制。随着应用的扩张，线程和任务管理也 变得非常复杂。为了简化这些复杂的线程管理模式，我们需要一个 “管理者”来统一管理线程及任务分配，这就是线程池。</p><p>线程池的架构图大致如下：</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/b23df79f36c79d22.png"></p><h6 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h6><p>​Executor是Java异步目标任务的“执行者”接口，其目标是执行 目标任务。“执行者”Executor提供了execute()接口来执行已提交的 Runnable执行目标实例。Executor作为执行者的角色，其目的是提供 一种将“任务提交者”与“任务执行者”分离开来的机制。</p><p>只包含一个函数式方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span></span><br></pre></td></tr></table></figure><h6 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h6><p>​继承于Executor。他是Java异步目标任务的“执行者服务”接口，对外提供异步任务的接受服务。</p><p>提 供了“接收异步任务并转交给执行者”的方法,如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向线程池提交单个异步任务</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"><span class="comment">//向线程池提交批量异步任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extendsCallable&lt;T&gt;&gt; tasks)</span><span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure><h6 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h6><p>​AbstractExecutorService是一个抽象类，它实现了 ExecutorService接口。AbstractExecutorService存在的目的是为 ExecutorService中的接口提供默认实现。</p><h6 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h6><p>​ThreadPoolExecutor是JUC线程池的核心实现类,继承 于AbstractExecutorService抽象类。线程的创建和终 止需要很大的开销，线程池中预先提供了指定数量的可重用线程，所 以使用线程池会节省系统资源，并且每个线程池都维护了一些基础的 数据统计，方便线程的管理和监控。</p><h6 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h6><p>​ScheduledExecutorService是一个接口，它继承于 ExecutorService。它是一个可以完成“延时”和“周期性”任务的调 度线程池接口，其功能和Timer&#x2F;TimerTask类似。</p><h6 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h6><p>​ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，它提 供了ScheduledExecutorService线程池接口中“延时执行”和“周期 执行”等抽象调度方法的具体实现。</p><p>​ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序 中，ScheduledThreadPoolExecutor的性能要优于Timer。</p><h6 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h6><p>​Executors是一个静态工厂类，它通过静态工厂方法返回 ExecutorService、ScheduledExecutorService等线程池示例对象，这 些静态工厂方法可以理解为一些快捷的创建线程池的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JUC线程池之线程池架构&quot;&gt;&lt;a href=&quot;#JUC线程池之线程池架构&quot; class=&quot;headerlink&quot; title=&quot;JUC线程池之线程池架构&quot;&gt;&lt;/a&gt;JUC线程池之线程池架构&lt;/h3&gt;&lt;p&gt;在多线程编程中，任务都是一些抽象且离散的工作单元，而线程 是</summary>
      
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="线程池" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>JUC之创建线程的几种方式</title>
    <link href="http://example.com/2023/04/02/JUC%E4%B9%8B%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2023/04/02/JUC%E4%B9%8B%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2023-04-02T03:24:56.000Z</published>
    <updated>2023-07-23T09:13:16.264Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="JUC之创建线程的几种方式"><a href="#JUC之创建线程的几种方式" class="headerlink" title="JUC之创建线程的几种方式"></a>JUC之创建线程的几种方式</h3><h4 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h4><p>​通过继承Thread类创建一个线程类，新的 线程子类重写了Thread的run()方法，实现了用户业务代码的并发执行，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaJUCstudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_TURN</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCurThreadName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Thread h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            h = <span class="keyword">new</span> <span class="title class_">TestThread</span>();</span><br><span class="line">            h.start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getCurThreadName()+<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestThread</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;TestThread:&quot;</span>+javaJUCstudy.threadId++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; javaJUCstudy.MAX_TURN; i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;,轮次:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​执行结果：</p><blockquote><p>main运行结束<br>TestThread:2,轮次:0<br>TestThread:1,轮次:0<br>TestThread:2,轮次:1<br>TestThread:1,轮次:1<br>TestThread:2,轮次:2<br>TestThread:1,轮次:2<br>TestThread:2,轮次:3<br>TestThread:1,轮次:3<br>TestThread:1,轮次:4<br>TestThread:2,轮次:4<br>TestThread:2结束<br>TestThread:1结束</p></blockquote><p>​TestThread类的关键点是重写了Thread类的run()方法， 将需要并发执行的用户业务代码编写在继承的run()方法中。</p><h4 id="实现Runnable接口创建线程目标类"><a href="#实现Runnable接口创建线程目标类" class="headerlink" title="实现Runnable接口创建线程目标类"></a>实现Runnable接口创建线程目标类</h4><p>​通过继承Thread类并重写它的run()方法只是创建Java线程的一种方式。接下来要介绍的一种方式是通过实现现Runnable接口创建线程目标类，在这之前我们先来看看Thread的run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> Runnable target;<span class="comment">//执行目标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();<span class="comment">//调用执行目标的run方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;<span class="comment">//包含执行目标的构造器</span></span><br><span class="line">        init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在Thread类的run()方法中，如果target（执行目标）不为空，就 执行target属性的run()方法。而target属性是Thread类的一个实例属 性，并且target属性的类型为Runnable。</p><p>​Thread类的target属性在什么情况下非空呢？Thread类有一系列 的构造器，其中有多个构造器可以为target属性赋值，这些构造器包 括如下两个：</p><pre><code>    1. public Thread(Runnable target)    1. public Thread(Runnable target，String name)</code></pre><p>​使用这两个构造器传入target执行目标实例（Runnable实例）， 就可以直接通过Thread类的run()方法以默认方式实现。而我们可以通过创建一个类来实现Runnbale接口来创建Runnable实例。通过实现Runnable接口创建线程类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> suan.JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RunnableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_TURN</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCurThreadName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestRunnable</span>();</span><br><span class="line">            h = <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;TestThread:&quot;</span>+threadId++);</span><br><span class="line">            h.start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(getCurThreadName()+<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; RunnableTest.MAX_TURN; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,轮次:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>TestThread:1,轮次:0<br>TestThread:2,轮次:0<br>TestThread:1,轮次:1<br>TestThread:2,轮次:1<br>TestThread:1,轮次:2<br>TestThread:2,轮次:2<br>TestThread:1,轮次:3<br>TestThread:2,轮次:3<br>TestThread:2,轮次:4<br>TestThread:1,轮次:4<br>TestThread:2结束<br>TestThread:1结束<br>main结束</p></blockquote><p>​实例中静态内部类RunTarget执行目标类，不再是继承Thread线程 类，而是实现Runnable接口，需要异步并发执行的代码逻辑被编写在 它的run()方法中。通过实现Runnable接口的方式创建的执行目标类，如果需要访问 线程的任何属性和方法，必须通过Thread.currentThread()获取当前 的线程对象，通过当前线程对象间接访问。</p><h5 id="使用实现Runnable接口创建线程目标类的简便写法"><a href="#使用实现Runnable接口创建线程目标类的简便写法" class="headerlink" title="使用实现Runnable接口创建线程目标类的简便写法"></a>使用实现Runnable接口创建线程目标类的简便写法</h5><p>​因为Runnable是一个函数式接口，在接口实现时可以使用Lambda 表达式提供匿名实现，来简化我们的代码。改进后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_TURN</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCurThreadName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; RunnableTest.MAX_TURN; j++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,轮次:&quot;</span>+j);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            &#125;,<span class="string">&quot;name&quot;</span>+threadId++).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(getCurThreadName()+<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><blockquote><p>name1,轮次:0<br>name2,轮次:0<br>name2,轮次:1<br>name2,轮次:2<br>name2,轮次:3<br>name2,轮次:4<br>name2结束<br>name1,轮次:1<br>name1,轮次:2<br>name1,轮次:3<br>name1,轮次:4<br>name1结束<br>main结束</p></blockquote><h4 id="使用Callable和FutureTask-创建线程"><a href="#使用Callable和FutureTask-创建线程" class="headerlink" title="使用Callable和FutureTask 创建线程"></a>使用Callable和FutureTask 创建线程</h4><p>​前面已经介绍了继承Thread类或者实现Runnable接口这两种方式 来创建线程类，但是这两种方式有一个共同的缺陷：不能获取异步执 行的结果。为了解决异步执行的结果问题，Java语言在1.5版本之后提供了一 种新的多线程创建方法：通过Callable接口和FutureTask类相结合创 建线程。</p><h5 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h5><p>Callable接口位于java.util.concurrent包中，查看它的Java源 代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callable接口是一个泛型接口，也是一个“函数式接口”。其唯 一的抽象方法call()有返回值，返回值的类型为Callable接口的泛型 形参类型。call()抽象方法还有一个Exception的异常声明，容许方法 的实现版本的内部异常直接抛出，并且可以不予捕获。但Callable接口不能像Runnable接口那样作为Thread线程实例的taiget使用，这就要引入RunnableFuture接口了。</p><h5 id="RunnableFuture接口"><a href="#RunnableFuture接口" class="headerlink" title="RunnableFuture接口"></a>RunnableFuture接口</h5><p>RunnableFuture接口与 Runnable接口、Thread类紧密相关，RunnableFuture接口实现了两个目标：一是可以作为Thread线程 实例的target实例，二是可以获取异步执行的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunnableFuture继承了Runnable接口，从 而保证了其实例可以作为Thread线程实例的target目标；同时， RunnableFuture通过继承Future接口，保证了可以获取未来的异步执 行结果。这里又需要引入Future接口了。</p><h5 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h5><p>Future接口至少提供了三大功能： </p><p>（1）能够取消异步执行中的任务。 </p><p>（2）判断异步任务是否执行完成。 </p><p>（3）获取异步任务完成后的执行结果。</p><p>Future接口的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;<span class="comment">//取消异步任务的执行。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;<span class="comment">//获取异步任务的取消状态。如果任务完成前被取消，就返回true。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;<span class="comment">//获取异步任务的执行状态。如果任务执行结束，就返回true。</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">//获取异步任务执行的结果。注意，这个方法的调用是阻塞性的。如果异步任务没有执行完成，异步结果获取线程（调用线程）会一直被阻塞，一直阻塞到异步任务执行完成，其异步结果返回给调用线程。</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">    <span class="comment">//设置时限，（调用线程）阻塞性地获取异步任务执行的结果。该方法的调用也是阻塞性的，但是结果获取线程（调用线程）会有一个阻塞时长限制，不会无限制地阻塞和等待，如果其阻塞时间超过设定的timeout时间，该方法将抛出异常，调用线程可捕获此异常。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h5><p>​FutureTask类是Future接口的实现类，提供了对异步任务的操作 的具体实现。但是，FutureTask类不仅实现了Future接口，还实现了 Runnable接口，或者更加准确地说，FutureTask类实现了 RunnableFuture接口。</p><p>​FutureTask实现了 RunnableFuture接口，而RunnableFuture接口继承了Runnable接口和 Future接口，所以FutureTask既能作为一个Runnable类型的target执 行目标直接被Thread执行，又能作为Future异步任务来获取Callable 的计算结果。</p><p>机构图如下：</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/dfd6bfec9a1bec0e.png"></p><h5 id="使用Callable和FutureTask创建线程的具体步骤"><a href="#使用Callable和FutureTask创建线程的具体步骤" class="headerlink" title="使用Callable和FutureTask创建线程的具体步骤"></a>使用Callable和FutureTask创建线程的具体步骤</h5><p>通过FutureTask类和Callable接口的联合使用可以创建能够获取 异步执行结果的线程，具体步骤如下：</p><p>（1）创建一个Callable接口的实现类，并实现其call()方法，编 写好异步执行的具体逻辑，可以有返回值。</p><p>（2）使用Callable实现类的实例构造一个FutureTask实例。</p><p>（3）使用FutureTask实例作为Thread构造器的target入参，构造 新的Thread线程实例。</p><p>（4）调用Thread实例的start()方法启动新线程，启动新线程的 run()方法并发执行。其内部的执行过程为：启动Thread实例的run() 方法并发执行后，会执行FutureTask实例的run()方法，最终会并发执 行Callable实现类的call()方法。</p><p>（5）调用FutureTask对象的get()方法阻塞性地获得并发线程的 执行结果。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> suan.JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_TURN</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPUTE_TIMES</span> <span class="operator">=</span> <span class="number">100000000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCurThreadName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ReturnTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReturnTask</span>();</span><br><span class="line">        FutureTask&lt;Long&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;有返回值的异步线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(getCurThreadName()+<span class="string">&quot;等一会&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; COMPUTE_TIMES/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * <span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getCurThreadName()+<span class="string">&quot;获取异步执行的结果&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">&quot;线程占用时间&quot;</span>+futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReturnTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程开始运行&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; FutureTaskTest.COMPUTE_TIMES; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * <span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">useTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程运行结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> useTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>有返回值的异步线程线程开始运行<br>main等一会<br>有返回值的异步线程线程运行结束<br>main获取异步执行的结果<br>有返回值的异步线程线程占用时间1010<br>运行结束</p></blockquote><h4 id="通过线程池创建线程"><a href="#通过线程池创建线程" class="headerlink" title="通过线程池创建线程"></a>通过线程池创建线程</h4><p>前面的示例中，所创建的Thread实例在执行完成之后都销毁了， 这些线程实例都是不可复用的。实际上创建一个线程实例在时间成 本、资源耗费上都很高，在高并发的场景中，断然不 能频繁进行线程实例的创建与销毁，而是需要对已经创建好的线程实 例进行复用，这就涉及线程池的技术。Java中提供了一个静态工厂来 创建不同的线程池，该静态工厂为Executors工厂类。</p><p>向ExecutorService线程池提交异步执行target目标任务的常用方法有：</p><ol><li>执行一个 Runnable类型的target执行目标实例，无返回 。</li></ol><p>​void execute(Runnable command);</p><ol start="2"><li>提交一个 Callable类型的target执行目标实例, 返回一个 Future异步任务实例</li></ol><p>​Future submit(Callable task);</p><ol start="3"><li>提交一个 Runnable类型的target执行目标实例, 返回一个 Future异步任务实例</li></ol><p>​Future submit(Runnable task);</p><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> suan.JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_TURN</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPUTE_TIMES</span> <span class="operator">=</span> <span class="number">100000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        pool.execute(<span class="keyword">new</span> <span class="title class_">demoThread</span>());</span><br><span class="line">        pool.execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_TURN; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;, 轮次: &quot;</span>+i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;Long&gt; submit = pool.submit(<span class="keyword">new</span> <span class="title class_">ReturnTaskTest</span>());</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> (Long)submit.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;异步执行的结果：&quot;</span>+result);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demoThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ExecutorsTest.MAX_TURN; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;, 轮次: &quot;</span>+ i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReturnTaskTest</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程开始运行&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ExecutorsTest.MAX_TURN; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;, 轮次: &quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">useTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程运行结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> useTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>pool-1-thread-1, 轮次: 0<br>pool-1-thread-1, 轮次: 1<br>pool-1-thread-1, 轮次: 2<br>pool-1-thread-2, 轮次: 0<br>pool-1-thread-3线程开始运行<br>pool-1-thread-1, 轮次: 3<br>pool-1-thread-2, 轮次: 1<br>pool-1-thread-1, 轮次: 4<br>pool-1-thread-2, 轮次: 2<br>pool-1-thread-2, 轮次: 3<br>pool-1-thread-2, 轮次: 4<br>pool-1-thread-3, 轮次: 0<br>pool-1-thread-3, 轮次: 1<br>pool-1-thread-3, 轮次: 2<br>pool-1-thread-3, 轮次: 3<br>pool-1-thread-3, 轮次: 4<br>pool-1-thread-3线程运行结束<br>异步执行的结果：1086<br>main结束</p></blockquote><p>此时虽然main方法的线程结束了，但是线程池中的线程还没有结束，程序还没有停止。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/1986060cd7c36171.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;JUC之创建线程的几种方式&quot;&gt;&lt;a href=&quot;#JUC之创建线程的几种方式&quot; class=&quot;headerlink&quot; title=&quot;JUC之创建线程的几种方式&quot;&gt;&lt;/a&gt;JUC之创建线程的几种方式&lt;/h3&gt;&lt;h4 id=&quot;继承Thread</summary>
      
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC之进程与线程</title>
    <link href="http://example.com/2023/03/26/JUC%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2023/03/26/JUC%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-03-26T03:24:56.000Z</published>
    <updated>2023-07-23T09:14:30.787Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="JUC之进程与线程"><a href="#JUC之进程与线程" class="headerlink" title="JUC之进程与线程"></a>JUC之进程与线程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><h5 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h5><p>​什么是进程呢？简单来说，进程是程序的一次启动执行。什么是 程序呢？程序是存放在硬盘中的可执行文件，主要包括代码指令和数 据。一个进程是一个程序的一次启动和执行，是操作系统将程序装入 内存，给程序分配必要的系统资源，并且开始运行程序的指令。</p><p>​ 进程与程序是什么关系呢？同一个程序可以多次启动，对应多个 进程。比如，多次打开Chrome浏览器程序，对应的就是多个Chrome进程。</p><h5 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h5><p>​进程是程序执行和系统进行并发调度的最小单位。一般来说一个进程是由程序段、数据段和程序控制块三部分组成。进程结构图如下：</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/4b27944020f21cca.png"></p><h6 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h6><p>​程序段一般也被称为代码段。代码段是进程的程序指令在内存中的位置，包含需要执行指令的集合。</p><h6 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h6><p>​数据段是进程的操作数据在内存中的位置，包含需要操作的数据集合。</p><h6 id="程序控制块"><a href="#程序控制块" class="headerlink" title="程序控制块"></a>程序控制块</h6><p>​程序控制块（Program ControlBlock，PCB）包含进程的描述信息和控制信息，是进程存在的唯一标志。</p><p>​<strong>描述信息</strong>：主要包括进程ID和进程名称，进程ID是唯一的，代表进程的身份；进程状态，比如运行、就绪、阻塞；进程优先级，是进程调度的重要依据。</p><p>​<strong>调度信息</strong>：主要包括程序起始地址，程序的第一行指令的内存地址，从这里开始程序的执行；通信信息，进程间通信时的消息队列。</p><p>​<strong>资源信息</strong>：主要包括内存信息，内存占用情况和内存管理所用的数据结构；I&#x2F;O设备信息，所用到的I&#x2F;O设备编号及相应的数据结构；文件句柄，所打开文件的信息。</p><p>​<strong>进程上下文</strong>：主要包括执行时各种CPU寄存器的值、当前程序计数器（PC）的值以及各种栈的值等，即进程的环境。在操作系统切换进程时，当前进程被迫让出CPU，当前进程的上下文就保存在PCB结构中，供下次恢复运行时使用。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>​Java编写的程序都运行在Java虚拟机（JVM）中，每当使用Java命 令启动一个Java应用程序时，就会启动一个JVM进程。在这个JVM进程 内部，所有Java程序代码都是以线程来运行的。JVM找到程序的入口点 main()方法，然后运行main()方法，这样就产生了一个线程，这个线 程被称为主线程。当main()方法结束后，主线程运行完成，JVM进程也 随即退出。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><h5 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h5><p>​早期的操作系统只有进程而没有线程，随着科技的发展，CPU的性能越来越高，而且从单核CPU发展为多核CPU，为了充分发挥CPU的计算性能，提升CPU硬件 资源的利用率，同时弥补进程调度过于笨重产生的问题，进程内部演 进出了并发调度的诉求，于是就发明了线程。</p><p>​线程是指“进程代码段”的一次顺序执行流程。一个进程可以有一个或多个线程，各个线程之间共享进程 的内存空间、系统资源，进程仍然是操作系统资源分配的最小单位。</p><h5 id="线程的组成"><a href="#线程的组成" class="headerlink" title="线程的组成"></a>线程的组成</h5><p>​线程是CPU调度的 最小单位。一个标准的线程主要由三部分组成，即线程描述信息、程序计数 器（Program Counter，PC）和栈内存。线程结构图如下：</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/e3e7e20c5c1b6c45.png"></p><h6 id="线程描述信息"><a href="#线程描述信息" class="headerlink" title="线程描述信息"></a>线程描述信息</h6><p>​线程的描述信息即线程的基本信息。</p><p>​<strong>线程ID</strong>：线程的唯一标识，同一个进程内不同线程的ID不会重叠。</p><p>​<strong>线程名称</strong>：主要是方便用户识别，用户可以指定线程的名字，如果没有指定，系统就会自动分配一个名称。</p><p>​<strong>线程优先级</strong>：表示线程调度的优先级，优先级越高，获得CPU的执行机会越大。</p><p>​<strong>线程状态</strong>：标识当前线程的执行状态，为新建、就绪、运行、阻塞、结束等状态中的一种。</p><p>​其他的一些信息，如是否为守护线程等。</p><h6 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h6><p>​在线程的结构中，程序计数器很重要，它记录着线程下一条指令的代码段内存地址。</p><h6 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h6><p>​在线程的结构中，占内存是代码段中局部变量的存储空间，为线程所独立拥有，在线程之间不共享。在JDK1.8中，每个线程在创建是默认被分配1MB大小的栈内存。栈内存和堆内存不同，栈内存不受垃圾回收器管理。</p><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><p>​Java程序的进程执行过程就是标准的多线程的执行过程。每当使 用Java命令执行一个class类时，实际上就是启动了一个JVM进程。理 论上，在该进程的内部至少会启动两个线程，一个是main线程，另一 个是GC（垃圾回收）线程。实际上，执行一个Java程序后，线程数量远远不止两个，达到了18个之 多。</p><h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><ol><li>线程是“进程代码段”的一次顺序执行流程。一个进程由一个或多个线程组成，一个进程至少有一个线程。</li><li>线程是CPU调度的最小单位，进程是操作系统分配资源的最小单位。线程的划分尺度小于进程，使得多线程程序得并发性高。</li><li>线程是出于高并发得调度诉求从进程内部演进而来的。线程的出现既充分发挥了CPU的计算性能，又弥补了进程调度过于笨重的问题。</li><li>进程之间是相互独立的，但进程内部的各个线程之间并不完全独立。各个线程之间共享进程的方法区内存、堆内存、系统资源（文件句柄、系统信号等）。</li><li>切换速度不同，线程上下文切换比进程上下文切换要快得多。所以有的时候线程也称为轻量级进程。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;JUC之进程与线程&quot;&gt;&lt;a href=&quot;#JUC之进程与线程&quot; class=&quot;headerlink&quot; title=&quot;JUC之进程与线程&quot;&gt;&lt;/a&gt;JUC之进程与线程&lt;/h3&gt;&lt;h4 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=</summary>
      
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>呼啸山庄读后感</title>
    <link href="http://example.com/2023/03/25/%E5%91%BC%E5%95%B8%E5%B1%B1%E5%BA%84%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>http://example.com/2023/03/25/%E5%91%BC%E5%95%B8%E5%B1%B1%E5%BA%84%E8%AF%BB%E5%90%8E%E6%84%9F/</id>
    <published>2023-03-25T03:19:30.000Z</published>
    <updated>2023-07-23T08:20:42.210Z</updated>
    
    <content type="html"><![CDATA[<h3 id="呼啸山庄读后感"><a href="#呼啸山庄读后感" class="headerlink" title="呼啸山庄读后感"></a>呼啸山庄读后感</h3><p>《呼啸山庄》是一部在英国十九世纪文坛上焕发异彩的天才之作。它狂放不羁的浪漫主义风格蕴含在阴冷而暴力，神秘怪诞又隐隐约约透出神圣温情的背景中，整个场景是一个封闭的小社会——两个孤立的山庄和开放的大自然与荒原，书中人物身上体现出爱与恨两种极端，极度的爱中混杂着极度的恨，使小说在颤栗中呈现出极为强烈的戏剧化色彩。</p><p>英国著名作家毛姆曾评论说 ：“我不知道还有哪一部小说其中爱情的痛苦、迷恋、残酷、执著，曾经如此令人吃惊地描述出来。《呼啸山庄》使我想起埃尔·格里科的那些伟大的绘画中的一幅，画上是一片乌云下的昏暗的荒瘠土地的景色，雷声隆隆拖长了的憔悴的人影东歪西倒，被一种不是属于尘世间的情绪弄得恍恍惚惚，他们屏息着。铅色的天空掠过一道闪电，给这一情景加上最后一笔，增添了神秘的恐怖之感。”</p><p>《呼啸山庄》出版于1847年，是英国女作家艾米莉·勃朗特唯一的一部小说作品，初问世时，它颇受冷落；但随着岁月的流逝，其别具一格的艺术魅力征服了越来越多的读者。而今，在西方文学的经典书单中，它已与《战争与和平》这样的巨著分庭抗礼了。</p><p>拿着《呼啸山庄》这本书，我就在想它为什么以呼啸山庄命名？呼啸二字又代表什么意思？看着看着我渐渐明白了：1、书中的一个山庄名为呼啸山庄，而整本书都围绕此山庄而写。2、书中的环境描写相当惊悚、悬疑。荒野、悲风、暴雪、黑夜，尤其是那鬼哭狼嚎、悲风鸣鸣的渲染，让人心中只有令人发麻的“呼啸”二字，它在呼啸什么？是呼啸希斯克厉夫的可悲、可怜、可恨？是呼啸凯瑟琳的虚荣绝情？还是呼啸林谆、小凯瑟琳及希斯克厉夫少爷等人作为复仇牺牲品的可气、可叹？也许都有吧！《呼啸山庄》是讲爱恨情仇的故事，与其这样说还不如说它是恋爱之人的谆谆教诲，经血的教训来诠释爱情的忠贞与背叛，爱可以无私伟大的，同样可以是恐怖邪恶的。</p><p>终于明白了：爱与恨，可以背道而驰，可以相生相伴！</p><p>《呼啸山庄》的主题是常见的爱情与复仇，情节也很简单。主人公希刺克厉夫是利物浦街头的弃儿，老恩萧先生收养了他，把他带到呼啸山庄，并对他宠爱有加。老恩萧的宠爱引起了其子辛德利的嫉妒和仇视。老恩萧一死，辛德利便对他进行了残酷的折磨，剥夺他受教育的机会，把他撵出客厅，沦为奴隶。但老恩萧之女凯瑟琳却始终同情他，站在他一边，与他联合起来反抗辛德利的暴政，并在共同的反抗中孕育出一种根植于生命最深处的爱情。然而这种感情在凯瑟琳见到画眉山庄舒适而体面的生活的时候起了变化，最后她以一念之差嫁给了画眉山庄的少爷——英俊、富有、温文尔雅的埃德加·林惇。希刺克厉夫愤而出走，三年后衣锦还乡，开始大施报复。凯瑟琳旧情复萌，伤心而死，遗下一女小凯瑟琳。希刺克厉夫为谋画眉山庄的产业，强娶埃德加·林惇之妹伊莎贝拉，得子小林惇；又与辛德利赌博，赢其家产，在其死后又收容其子哈里顿，以其当年待己之道而待之。十几年后，三个孩子渐已长大；希刺克厉夫又施计谋，胁迫小凯瑟琳与病势沉重的小林惇成婚，不久小凯瑟琳父丧夫亡，希刺克厉夫终于将两家财产夺于手中。但此时他对凯瑟琳多年的思念已压过了他的求生欲望，终于在一场暴风雨中神秘地死去。而哈里顿与小凯瑟琳则前嫌尽释、共结同心，预备婚后移居画眉山庄，而曾经风雨的呼啸山庄则将沉入寂静之中。</p><p>荒原是《呼啸山庄》的永恒背景和底蕴，它展现了人性中的刚劲、野性和激情，描写了一种狂放不羁、自由洒脱的性情，是人的本能的激烈释放。透过它我们能聆听到困于现实的灵魂挣扎着返回本真的凄惨而绝望的叹息。《呼啸山庄》的神秘性和奇特性是《简·爱》和其它小说所难以比拟的。正因为如此，它比其它小说更难让人理解，更难让人接受。它所表现的是一种荒原之美，饱含刚劲，野性和激情。《呼啸山庄》的每一章都肆虐着山呼海啸，狂风暴雨，以其撕心裂肺的情感力度震撼着读者的内心。而常人所喜欢的温婉，雅致，娇柔在这里都成了一种孱弱，毫无价值的东西。《呼啸山庄》直接指向人的灵魂。读者无法从《呼啸山庄》中感受到情感的美妙，愉悦，扑面而来的是灵魂的激烈震荡与冲突。爱与恨以超越人类极限的强度展现出来。这种展现突破了人类社会文明的界限，几乎是人性中炽烈的激情的再现。我们在呼啸而过的狂风中听到了灵魂深处的回应。这样的呼喊与回应，这样的野性与激情，就是荒原气质，也正是《呼啸山庄》的精神内核，它如利箭贯胸般穿透全书，又像花蕾绽放般扩散开来，震撼读者的身心。</p><p>《呼啸山庄》中所体现的爱情虽不是轰轰烈烈，但体现了爱情的忠贞和伟大。希刺克厉夫对凯瑟琳那至死不渝的爱，凯瑟琳那震撼人心的呼喊：“我就是希刺克厉夫，希刺克厉夫就是我，我们的灵魂是用同一块粒子做成的。”多么感人至深的爱情宣言，我想，这也是爱到深处的自然流露吧。虽然他们的结局并不圆满，但是他们收获了真爱，将爱情的真谛演绎到极致，作为旁观者，不禁对他们凄美的爱情感到惋惜，同时又心生敬意和感慨：爱情是如此崇高和伟大。书中还体现了这样一个主题：只要有合适的土壤，人性是会复苏的。小凯瑟琳与哈里顿对山庄访客洛克乌德先生的有限的关心，山庄女管家齐拉的理智等等，在那个阴暗的环境里，无一不召示了人类心灵深处那颗本善的心，哈里顿与小凯瑟琳的最后结合也正是说明了这一点，虽然他们走到一块的过程是那么的坎坷与磨难，但他们最终走到了一起，就像文中预示的那样，终将过上幸福的日子。人性美最终战胜了人性恶，美好的人性最终得到了复苏。</p><p>我记得拿破伦曾经说过一句著名的话：“如果有人嘲笑我个子矮，我就砍去他的头，这样他就和我一样高了”。我想相信希斯克利夫和拿破伦的想法一样：与其没有尊严，任人欺凌地度过一生，还不如痛痛快快地较量一番。既然弱者不得好活，强者也不得好死。正是爱与恨的鲜明反差，正是特殊环境下的爱恨情仇造成了希斯克利夫那份独特的个性，而那份独特的个性，又如火山的迸发，成了疯狂的复仇动力。</p><p>再看希刺克厉夫，就那个时代来说，是值得同情的人物，他的复仇是可以理解的。十几年来，凯瑟琳的孤魂在旷野上彷徨哭泣，等待着希刺克厉夫，终于希刺克厉夫离开了人世，他们在另一个世界相聚，彼此的灵魂不再孤独，黑夜里在旷野上，山岩底下散步……正如作者最后写道：“我在那温和的天空下面，在这三块墓碑前留连，望着飞蛾在石南丛和兰铃花中扑飞，听着柔风在草间飘动，我纳闷有谁能想象得出在那平静的土地下面的长眠者竟会有并不平静的睡眠。”希刺克厉夫与凯瑟琳那种不为世俗所压服、忠贞不渝的爱情也正是对他们所处的被恶势力所操纵的旧时代的一个顽强的反抗，尽管他们的反抗是徒劳无力的，但他们的爱情在作者的笔下战胜了死亡，达到了升华境界。他们的相爱也正是人性美的一种复苏与兴盛吧！</p><p>故事是以希斯克利夫达到复仇目的而自杀告终的。他的死是一种殉情，表达了他对凯瑟琳生死不渝的爱，一种生不能同食，死也求同穴的爱的追求，而他临死前放弃了在下一代身上报告的念头，表明他的天性本来是善良的，只是由于残酷的现实扭曲了他的天性，迫使他变得暴虐无情。这种人性的复苏是种精神上的升华，闪耀着作者人道主义的理想。</p><p>虽然这是个悲剧，但却非常感谢艾米莉，或许，她真的抓住了爱的精髓。</p><p>由爱的开始的恨应该经爱的终结，无法被宽恕的爱，只能永远延续下去，不管以何种方式，直至相爱的人获得解释。克厉夫或许是该死的，是应该被惩罚的罪人，然而，他终其一生未能与凯瑟琳长相厮守，长达二十年的时间天人永隔，难道不正是为他的爱与恨付出应有的借贷，接受最残酷的惩罚吗？那种孤独、恐惧和绝望是等待与幽灵会面的焦虑和期待就象一把钝刀，一刀刀削割他的灵魂，一点点侵蚀他的肉体，最终把他推向死亡。</p><p>今天的读者已经获得了足够的认知和开明的观点，抛开虚假的道义教条和做作的品位情调，我们已经可以理解女作家为什么被称为超越时代的天才。她笔下的克厉夫在被所有人唾弃的同时，却从人性的角度展现了奇特耀眼的光彩，永恒的爱和至深的恨赋予他独特的魅力，一种散发着狂野欲望、不受约束的个性魅力。正如小说开头所描写的荒野之树，它是扭曲变态的，却最不加修饰、自然生成的。克厉夫的一切都是环境造成的，他就是那荒野之树，努力地生存，抗拒着狂风暴雨，在变成了这样的丑态之后，用丑恶对抗、报复这制造丑恶的严酷环境。</p><p>一个遵循传统、保守道德规范的英国淑女，以如此独特、敏锐的视角揭示了人性，探讨了人性，理解了人性。在她的笔下，爱与恨以一种最自由的状态得到了释放、延伸，她给我们看到了人性最美也是最丑的一面，让我们探寻到任何人内心都无法逃避的善与恶。</p><p>不可否认这一篇小说涵盖的东西远远超越了爱情的本身它赞扬了人的美德抨击了人心的黑暗用世俗的生活画卷了他们对美好的追求。我们从中学到的是如何把自我与他人对照来发现自己的缺点洗却心灵的肮脏同时也教给我们如何面对世界如何以自己的爱来换取世界的光明。这样我们在迈向文明生活和爱情社会的路上看到的正式新生命的不屈再生。</p><p>暴风雪过后终将是万里晴空的清爽和平静，震撼过后留下深深的思索和无限的遐想。合上《呼啸山庄》，我只希望克厉夫和凯瑟琳在结束一代人的爱恨情仇后，在荒野间获得真正永恒的宁静……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;呼啸山庄读后感&quot;&gt;&lt;a href=&quot;#呼啸山庄读后感&quot; class=&quot;headerlink&quot; title=&quot;呼啸山庄读后感&quot;&gt;&lt;/a&gt;呼啸山庄读后感&lt;/h3&gt;&lt;p&gt;《呼啸山庄》是一部在英国十九世纪文坛上焕发异彩的天才之作。它狂放不羁的浪漫主义风格蕴含在阴冷而暴力，</summary>
      
    
    
    
    <category term="作业" scheme="http://example.com/categories/%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="读后感" scheme="http://example.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>JVM之java虚拟机中对象创建过程</title>
    <link href="http://example.com/2023/03/20/JVM%E4%B9%8Bjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2023/03/20/JVM%E4%B9%8Bjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</id>
    <published>2023-03-20T03:24:56.000Z</published>
    <updated>2023-07-23T09:22:47.803Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="JVM之java虚拟机中对象创建过程"><a href="#JVM之java虚拟机中对象创建过程" class="headerlink" title="JVM之java虚拟机中对象创建过程"></a>JVM之java虚拟机中对象创建过程</h3><p>我们平常创建一个对象，仅仅只是使用new关键字new一个对象，这样一个对象就被创建了，但是在我们使用new关键字创建对象的时候，在java虚拟机中一个对象是如何从无到有被创建的呢，我们接下来就来谈谈在java虚拟机中一个对象的创建过程（仅指我们平常使用的对象，不包括数组对象和Class对象）。</p><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>在了解对象的创建过程之前，我们先说说对象的内存布局，在HotSpot虚拟机中，对象在堆中的存储布局可以划分为三部分：对象头(Header)、示例数据(Instance Data)和对齐填充(Padding)。</p><h6 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h6><p>HotSpot虚拟机对象的对象头包括两类信息。</p><p>第一类是用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p><p>对象头的另一部分是类型指针，即对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例。</p><p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据信息推断出数组的大小。</p><h6 id="实例数据-Instance-Data"><a href="#实例数据-Instance-Data" class="headerlink" title="实例数据(Instance Data)"></a>实例数据(Instance Data)</h6><p>这部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的自读那都必须记录起来。这部分的存储顺序会 受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。 HotSpot虚拟机默认的分配顺序为longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops（Ordinary Object Pointers，OOPs）。</p><p>如果HotSpot虚拟机的 +XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空 隙之中，以节省出一点点空间。</p><h6 id="对齐填充-Padding"><a href="#对齐填充-Padding" class="headerlink" title="对齐填充(Padding)"></a>对齐填充(Padding)</h6><p>这部分不是必须存在的，也没有特殊的意义，它仅仅起到占位符的作用。</p><p>由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是 任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者 2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>当Java虚拟机遇到一条字节码new指令时，会首先去检查这个指令的参数是否能正常在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有那必须先执行相应的类加载过程。</p><p>在类加载完成后对象所需的内存大小便已经确定，接下来就是给新对象在java堆中分配存储空间，这个过程相当于是将一块确定大小的内存块从java堆中划分出来，这个过程有两种方式：</p><ol><li><p>指针碰撞</p><p>这种方式适用于Java堆中的内存空间是规整的情况，这种情况下被使用的内存在一边，空闲的空间在另一边，中间放着一个指针作为分界点的指示器，这种情况下分配内存就只是将中间的指针向空闲空间的方向移动一段与对象大小相等的距离即可。</p></li><li><p>空闲列标</p><p>这种方式适用于Java堆中的内存空间是不规整的情况，这种情况下适用过的内存和空闲的内存交错在一起，这样就不能使用简单的指针碰撞来给对象分配内存了。此时虚拟机维护了一个列表，记录了哪些内存块是可用的，在给对象分配内存时，从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录即可。</p></li></ol><p>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值。这步保证了对象的实例字段在Java代码可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><p>接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到 类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才 计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。</p><p>在上面的工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了。但是从Java程序的角度来看，对象的创建才刚刚开始，因为构造函数（即Class文件中的init方法）还没有执行，所有的字段都还是默认的零值。一般来说，new指令之后会接着执行 ()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具 体对象。对象的访问方式是由虚拟机实现而定的，主流的访问方式有使用句柄和直接指针两种。</p><h6 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h6><p>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就 是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/28db0026ec33c7d7.png"></p><h6 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h6><p>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关 信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问 的开销。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/a9d82ee793b1c112.png"></p><p>这两种对象访问方式都各有优势，使用句柄访问的最大好处就是reference中存储的时稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不会被修改。</p><p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访 问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;JVM之java虚拟机中对象创建过程&quot;&gt;&lt;a href=&quot;#JVM之java虚拟机中对象创建过程&quot; class=&quot;headerlink&quot; title=&quot;JVM之java虚拟机中对象创建过程&quot;&gt;&lt;/a&gt;JVM之java虚拟机中对象创建过程&lt;</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="对象" scheme="http://example.com/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JVM之java虚拟机内存分布</title>
    <link href="http://example.com/2023/03/20/JVM%E4%B9%8Bjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"/>
    <id>http://example.com/2023/03/20/JVM%E4%B9%8Bjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</id>
    <published>2023-03-20T03:24:56.000Z</published>
    <updated>2023-07-23T09:21:41.492Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="JVM之java虚拟机内存分布"><a href="#JVM之java虚拟机内存分布" class="headerlink" title="JVM之java虚拟机内存分布"></a>JVM之java虚拟机内存分布</h3><p>Java虚拟机在执行java程序的过程中会把它所管理的内存划分为如下若干个不同的数据区域。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/6efd25d6c55dadb3.png"></p><h4 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h4><p>程序计数器是线程私有的，它占用的空间相对较小，用来记录当前线程字节码执行到哪一步。字节码解释器通过改变这个计数器的值来获取当前线程下一步需要执行的指令，以此来确保在多条线程相互切换之后还能正确的回到切换之前执行的那一步指令。</p><p>需要注意的是如果当前线程正在执行的是一个Java方法，那么程序计数器记录的就是正在执行的虚拟机字节码指令的地址；如果当前线程正在执行的是本地(Native)方法，那此时程序计数器的值为空(Undefined)。</p><p>并且程序计数器所在的内存区域是在《java虚拟机规范》中唯一一个没有规定任何OutOfMemory Error情况的区域。</p><h4 id="2-堆"><a href="#2-堆" class="headerlink" title="2.堆"></a>2.堆</h4><p>Java堆（Java Heap）是虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。Java堆的目的就是为了存放Java对象，几乎所有的Java对象实例都在Java堆中分配内存。java堆是垃圾收集器工作的主要区域。</p><p>Java堆既可以被设置为固定大小，也可以被设置为可扩展的（通过参数-Xmx和-Xms设定）。如果在堆中没法完成实例分配，且堆也不能在扩展时，就会抛出OutOfMemoryError异常。</p><ul><li>“-Xmx” 用于设置堆的起始内存</li><li>“-Xms” 用于设置堆的最大内存</li></ul><h4 id="3-方法区"><a href="#3-方法区" class="headerlink" title="3.方法区"></a>3.方法区</h4><p>方法区(Method Area) 与Java堆一样是线程共享的区域，它用于存储已被Java虚拟机加载的类型信息、常量、静态变量。即时编译器编译后的代码缓存等数据。</p><p>如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</p><h5 id="3-1运行时常量池"><a href="#3-1运行时常量池" class="headerlink" title="3.1运行时常量池"></a>3.1运行时常量池</h5><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，如String类的 intern()方法。</p><p>当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h4 id="4-虚拟机栈"><a href="#4-虚拟机栈" class="headerlink" title="4.虚拟机栈"></a>4.虚拟机栈</h4><p>虚拟机栈（Java Virtual Machine Stack）是线程私有的，它的生命周期和线程一样。虚拟机栈是描述java方法执行的线程内存模型，每个方法被执行是都会创建一个栈帧（Stack Frame），用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从被调用到执行完毕的过程，都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存时，会抛出OutOfMemoryError异常。</p><h5 id="4-1栈帧"><a href="#4-1栈帧" class="headerlink" title="4.1栈帧"></a>4.1栈帧</h5><p>栈帧包括局部变量表、操作数栈、动态链接、方法出口等。</p><ol><li><p>局部变量表（LocalVariables）</p><p>用来存放编译器可知的各种Java虚拟机数据类型，包括基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。</p><p>这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，64为的long和double类型的数据会占用两个槽，其余的数据类型都只占用一个槽。如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索 引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐 含的参数。</p><p>在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方 法所需分配的局部变量表的最大容量。</p><p>局部变量表所需的空间在编译期间完成分配，在进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在运行期间不会改变局部变量大小（即槽的数量）。这其中还包含了槽的复用问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        String b=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//。。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>就以上这个Test方法来说，代表本方法的this变量占一个槽位，int类型的变量a占一个槽位，String类型的变量b占一个槽位，int类型的c占一个槽位，那么总共应该是有四个槽位，也就是局部变量表的最大槽数应该为4，但是我们看他的槽位显示只有三个。</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/050a353289355332.png"></p><p>我们再来看他的槽位详细信息，</p><p><img src="https://tt.xtt.ovh/imgs/2023/07/23/f24cce5f51a58472.png"></p><p>可以看到确实只有三个，分别是this变量，a和c。在我们的代码中明明定义了String类型的b变量，但是在槽位中却没有体现，这其实就是槽位的复用问题。对于作用域比较小的变量，在他完成自己的使命后，若是之后还有变量需要使用槽位，就会使用这个已经完成使命的变量的槽位，所以这里的第三个槽位中的变量是c而不是b。</p><ol start="2"><li>操作数栈</li></ol><p>操作数栈（Operand Stack）也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO） 栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项 之中。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。</p><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种 字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。如整数加法的字节码指令iadd，这条指令在运行的时候要 求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int 值出栈并相加，然后将相加的结果重新入栈。</p><ol start="3"><li><p>动态链接</p><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接（DynamicLinking）。Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态链接。</p></li><li><p>方法返回地址</p><p>当一个方法开始执行后，只有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法 返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用 者或者主调方法），方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种 退出方法的方式称为“正常调用完成”（Normal Method Invocation Completion）。</p><p>另外一种退出方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处 理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方 法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为“异常调用 完成（Abrupt Method Invocation Completion）”。一个方法使用异常完成出口的方式退出，是不会给它 的上层调用者提供任何返回值的。</p><p>无论采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用时的位置，程序才能继 续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。 一般来说，方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这 个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存 这部分信息。</p></li></ol><h4 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5.本地方法栈"></a>5.本地方法栈</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机 栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native） 方法服务。</p><p>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规 定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接 就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出StackOverflowError和OutOfMemoryError异常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;JVM之java虚拟机内存分布&quot;&gt;&lt;a href=&quot;#JVM之java虚拟机内存分布&quot; class=&quot;headerlink&quot; title=&quot;JVM之java虚拟机内存分布&quot;&gt;&lt;/a&gt;JVM之java虚拟机内存分布&lt;/h3&gt;&lt;p&gt;Java虚</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="虚拟机内存" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM之类加载过程</title>
    <link href="http://example.com/2023/03/17/JVM%E4%B9%8BJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2023/03/17/JVM%E4%B9%8BJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2023-03-17T03:24:56.000Z</published>
    <updated>2023-07-23T08:34:44.487Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="JVM之类加载过程"><a href="#JVM之类加载过程" class="headerlink" title="JVM之类加载过程"></a>JVM之类加载过程</h3><p>一个类型从被加载到虚拟机内存中开始，到卸载到内存中为止，他的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preoaration）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备和解析三个部分统称为连接（Linking）。</p><h4 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h4><p>这里得加载是指类加载过程中的第一步，而不是指类加载的整个过程，在这个阶段，虚拟机需要完成三件事。（在虚拟机中，类与加载它的类加载器一起构成其唯一性！）</p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p><p>需要注意的是这里的二进制字节流并不是只能从Class文件中获取，这就衍生很多的可能，其中比较常见的有：</p><ul><li>从ZIP压缩包中获取，这成为了日后JAR、EAR、WAR格式的基础</li><li>从网络中获取，这种场景最典型的就是Web Applet</li><li>运行时计算生成，这种场景使用的最多的是动态代理技术</li><li>由其他文件生成，典型的场景就是JSP应用，由JSP文件生成对应的Class文件</li><li>从数据库中读取，这种场景相对少见，有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发</li><li>可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探</li></ul></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p></li></ol><p>数组类的加载与普通类加载有所不同，数组本身不通过类加载器创建，它是由虚拟机直接在内存中动态构造出来的。但数组类与类加载器仍有很密切的关系，因为数组类的元素类型（ElementType,指的是数组去掉所有维度的类型）最终还要靠类加载器来完成加载，数组类的加载遵循以下规则：</p><ul><li>如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，与前面的元素类型不一样）是引用类型，那就递归加载这个组件类型，数组类将被标识在加载该组件类型的类加载器的类名空间上。</li><li>如果数组的组件类型不是引用类型（如int[] 数组的组件类型是int），java虚拟机将会把数组类标记为与引导类加载器关联。</li><li>数组类的可访问行与它的组件类型的可访问性一致，如果组件类型不是引用类型，他的数组类的可访问性将默认为public，可被所有的类可接口访问到。</li></ul><p>另外在加载阶段进行时，部分连接动作已经开始了（即这两部分是交叉进行的），但二者的开始时间仍有固定的先后顺序。</p><h4 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h4><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害到虚拟机自身的安全。验证阶段工作量庞大，我们只取一部分进行说明。验证阶段大致分为四步（文件格式验证、元数据验证、字节码验证和符号引用验证）：</p><ol><li><p>文件格式验证</p><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，验证内容包括：</p><ul><li>是否以魔数0xCAFEBABE开头</li><li>主、次版本号是否在当前虚拟机接受范围之内</li><li>常量池的常量是否有不被支持的常量类型（检查常量tag标志）</li><li>指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量</li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li></ul><p>等等，该验证阶段主要目的是保证输入的字节流能正确的解析并存储在方法区之内，格式上符合描述一个Java类型信息的要求。该阶段是基于二进制字节流验证的，只有通过了该阶段，字节流才被允许进入Java虚拟机内存的方法区中进行存储，下面的三个验证极端都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p></li><li><p>元数据验证</p><p>是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，包括：</p><ul><li>这个类是否有父类。除了java.lang.Object类之外，所有的类都应当有父类。</li><li>这个类的父类是否继承了不允许的被继承的类（被final修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（如覆盖了父类的final字段，或出现不符合规则的方法重载，如方法参数一致，但返回类型不一致等）。</li></ul><p>等等。</p></li><li><p>字节码验证</p><p>该阶段对类的方法体（Class文件中的Code属性）进行校验分析，确保被校验类的方法再运行时不会做出危害虚拟机安全的行为。包括：</p><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，避免出现在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中的情况。</li><li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与他毫无继承关系、完全不相干的一个数据类型，则是危险哥不合法的。</li></ul><p>等等。这是整个验证过程中最复杂的一个阶段，需要通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</p><p>需要注意的是，如果一个类型中有方法体的字节码没有通过字节码验证，那他一定是有问题的；但是如果它通过了，也不能说它一定就是安全的。</p></li><li><p>符号引用验证</p><p>该阶段的校验行为发生在虚拟机将符号引用转化为直接引用时，这个转化将在连接的第三阶段——解析中发生。该阶段可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验。就是看该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。包括：</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定的类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当前类访问。</li></ul><p>等等。符号引用验证的主要目的是确保解析行为能正常执行，若无法通过符号引用验证，Java虚拟机将会抛出一个java.lang.IncompatiableClassChangeError的子类异常，典型的如：java.lang.IllegalAccessError、java.lang..NoSuchFieldError、java.lang.NoSuchMethodError等。</p></li></ol><h4 id="准备（Preoaration）"><a href="#准备（Preoaration）" class="headerlink" title="准备（Preoaration）"></a>准备（Preoaration）</h4><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，不包括实例变量，实例变量是在对象实例化时对着对象一起分配在java堆中的。</p><p>初始值”通常情况”下是数据类型的零值，这里不包括基本数据类型的字段使用了static final修饰的情况，因为final在编译的时候就会分配内存了，准备阶段会显示赋值。而对于同样使用staic final修饰，且使用字面量的方式赋值的String类型变量来说，在准备阶段也是会显示赋值，而不是赋初值为null。</p><h4 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a>解析（Resolution）</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ul><li><p>符号引用（Symbolic References）:</p><p>是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标就行。</p></li><li><p>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存分布直接相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p></li></ul><p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行ane-warray、 checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、 invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于 操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p><p>通常情况下会对同一个符号引用进行多次解析请求，除invokedynamic指令以外，虚拟机实现可 以对第一次解析的结果进行缓存，从而避免解析动作重复进行。因为 invokedynamic指令的目的本来就是用于动态语言支持。它对应的引用称为“动态调用点限定符 （Dynamically-Computed Call Site Specifier）”，这里“动态”的含义是指必须等到程序实际运行到这条指 令时，解析动作才能进行。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7 类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CON-STANT_Fieldref_info、 CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、 CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和 CONSTANT_InvokeDynamic_info 8种常量类型。</p><h4 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h4><p>类的初始化时类加载的最后一个步骤，到这一步虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p><p>进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通 过程序编码制定的主观计划去初始化类变量和其他资源。</p><p>初始化阶段就是执行类构造器<clinit>()方法的过程。<clinit>()并不是程序员在Java代码中直接编写 的方法，它是Javac编译器的自动生成物。</p><ul><li><p><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的 语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问 到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同，它不需要显 式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行 完毕。因此在Java虚拟机中第一个被执行的<clinit>()方法的类型肯定是java.lang.Object。</p></li><li><p>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。字段B的值将会是2而不是1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">A = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(Sub.B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</p></li><li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法， 因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也 一样不会执行接口的<clinit>()方法。</p></li><li><p>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等 待，直到活动线程执行完毕<clinit>()方法。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</p></li></ul><p>需要注意的是，非静态变量不管是否进行显示赋值都不会生成<clinit>（）方法；静态变量没有显示赋值也不会生成<clinit>（）方法；对于使用static final修饰的常量，不管是否显式赋值都不会生成<clinit>（）方法；在同一个类加载器下，一个类只会被初始化一次。</p><h4 id="使用（Usuing）"><a href="#使用（Usuing）" class="headerlink" title="使用（Usuing）"></a>使用（Usuing）</h4><p>类的使用分为主动使用和被动使用。</p><p>主动使用：</p><ol><li>当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化</li><li>当调用类的静态方法时，即当使用了字节码invokestatic指令</li><li>当使用类、接口的静态字段时（final修饰特殊考虑），比如：使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）</li><li>当使用java.lang.reflect包中的方法反射类的方法时。比如:Class.forname(“com.atguigu.java.Test”)</li><li>当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li><li>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包括main（）方法的那个类），虚拟机会先初始化这个主类。</li><li>当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）</li></ol><p>被动使用：</p><ol><li>当访问一个静态字段 时，只有真正声明这个字段的类才会被初始化。<br>当通过子类引用父类的静态变量时，不会导致子类的初始化</li><li>通过数组定义类引用，不会触发此类的初始化</li><li>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显示赋值了</li><li>调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化</li></ol><h4 id="卸载（Unloading）"><a href="#卸载（Unloading）" class="headerlink" title="卸载（Unloading）"></a>卸载（Unloading）</h4><p>当一个类不再以任何方式被使用就会触发类的卸载，但这个条件往往比较苛刻，需要同时满足一下三个条件:</p><ol><li>该类所有的实例都已经被回收。也就是java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收。这个条件除非时经过精心设计的可替换类加载器的场景，<br>如OSGI、JSP的重加载等，否则通常时很难达成的</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;JVM之类加载过程&quot;&gt;&lt;a href=&quot;#JVM之类加载过程&quot; class=&quot;headerlink&quot; title=&quot;JVM之类加载过程&quot;&gt;&lt;/a&gt;JVM之类加载过程&lt;/h3&gt;&lt;p&gt;一个类型从被加载到虚拟机内存中开始，到卸载到内存中为止，他</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="类加载" scheme="http://example.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
</feed>
